#!/usr/bin/perl
#!/usr/bin/env perl
use Time::HiRes;
use Safe;

binmode STDOUT, ":encoding(utf-8)"; 

$scr_x = 0;
$scr_y = 0;

$scrw = 5;
$scrh = 3;

$spr_w = 1;  # Dimensions of a generic sprite. To be replaced with "sprite->{h}"
$spr_h = 1;  # of each particular sprite, not same for all sprs like now.
$py_spr_w = $spr_w;	# Dimensions of player sprite
$py_spr_h = 2*$spr_h;
 
$tile_width = 16;
$tile_height = 16;

$tile_width = 8;
$tile_height = 8;

$tile_width = $tile_height = $ENV{TILE_SIZE};

$tile_rows = int($tile_height / 2);
$pixel_width = 1/$tile_width;
$pixel_height = 1/$tile_height;
$fall_dec = 1 / 16;
$small_value = 0.005;

$state_file = $ENV{STATE};

$|++;
$num_objects = 0;

$origsprs = 88;

#$updps = 20;
$fps = 20;
$pdelay = 1000000/$fps;

$repaint = 0;
$sprmoved = 0;
$walk = 0;
$, = ", ";
$vx = 0;
$vy = 0;
$inair = 1;

# $data_dir = "data";
$level_name = $ARGV[0];
chdir $level_name;
sub draw_world;

$object_created = 0;

$compartment = new Safe;
$compartment->permit(qw(time sort :browse print require));

$exit_status = "Teleported";
$status = "Running";

$score = 0;

$constr_char = "Z";

sub reval($)
{
        my $cmd = shift;
        return $compartment->reval($cmd);
}

sub set_floor_shift
{
	sub draw_world;

	$floor_shift = $scrh - $floor_shift - 3;
	draw_world;
}

sub change_screen2 {
	while ($player->{x} > $scr_x + $scrw) {
		$scr_x += $scrw;
	}
	while ($player->{x} < $scr_x) {
		$scr_x -= $scrw;
	}
	while ($player->{y} > $scr_y + $scrh) {
		$scr_y += $scrh;
	}
	while ($player->{y} < $scr_y) {
		$scr_y -= $scrh;
	}
}

sub make_score_bar {
	print "curses:spr:score:6:1\n";
	print "curses:prc:score:0:0:7:6:              \n";
	print "curses:spr:coins:6:1\n";
	print "curses:prc:coins:0:0:7:6:              \n";
	print "curses:spr:constr:6:1\n";
	print "curses:prc:constr:0:0:7:6:              \n";
}

sub print_score {
	my $y = 2;
	my $mul = "\N{HEAVY MULTIPLICATION X}";
	if ($score) {
		print "curses:prc:score:0:0:3:6:\N{WHITE DRAUGHTS MAN}\n";
		print "curses:prc:score:1:0:0:6: $mul \n";
		print "curses:prc:score:4:0:7:6:$score\n";
		print "curses:mvs2:score:2:$y\n";
		$y += 2;	# Two because double coords.
	}
	if ($coins) {
		print "curses:prc:coins:0:0:1:6:\N{BLACK HEART SUIT}\n";
		print "curses:prc:coins:1:0:0:6: $mul \n";
		print "curses:prc:coins:4:0:7:6:$coins\n";
		print "curses:mvs2:coins:2:$y\n";
		$y += 2;
	}
	if ($show_constr_bar) {
		print "curses:prc:constr:0:0:1:6:F\n";
		print "curses:prc:constr:1:0:0:6: = \n";
		print "curses:prc:constr:4:0:7:6:$constr_char\n";
		print "curses:mvs2:constr:2:$y\n";
		$y += 2;
	}
	print "curses:ref\n";
}

sub print_pl_coord
{
	if (!$debuginfo) {
		return;
	}
	print "curses:pr:";
	print "posx=" . $player->{x};
	print ", posy=" . $player->{y};
	print ", flr_shft=$floor_shift";
	print ", nscrsy=$worldh/$scrh -1=$nscrsy";
	print ", rnscry=$rnscry";
	print ", start_y=$start_y";
	print ", inair=$inair";
	print ", climb_mode=$climb_mode";
	print ", scr_x=$scr_x";
	print ", debug_var=$debug_var";
	print ", oth_scr=" . $other_scr->{x} . "," . $other_scr->{y};
	print ", scr_size=" . $scrw . "," . $scrh;
	print "          \n";
	print "curses:ref\n";
}

sub print_dbg
{
	my $first=0;
	print "curses:pr:";

	for my $v (@_)
	{
		if ($first++) { print ", " }
		print "$v=" . eval("\$$v");
	}

	print "          \ncurses:ref\n";
}

sub change_screen;

sub load_object
{
	$module = shift;
	$module =~ s/[^A-Za-z:]//g;
	eval("use $module");
}

sub is_on_screen {
	my ($x, $y, $w, $h) = @_;

	if (($x + $w >= $scr_x) and ($x < $scr_x + $scrw) and
	    ($y + $h >= $scr_y) and ($y < $scr_y + $scrh)) {
		return 1;
	} else {
		return 0;
	}
}

sub obj_on_screen
{
	my $object = shift;
	my $x = $object->{x};
	my $y = $object->{y};
	my $w = $object->{w};
	my $h = $object->{h};

	return is_on_screen($x, $y, $w, $h);
}

sub destroy_object	# NOT USED
{
        my $obj = shift;
        @objects = grep {$_ != $obj} @objects;
}

sub destroy_object_id
{
        my $id = shift;
	undef $objects[$id];
}

sub id_to_object
{
        my $id = shift;

	for $obj (@objects) {
		if ($obj->{id} == $id) {
        		return $obj;
		}
	}
} 

sub get_objects_num
{
	return $num_objects;
}

sub load_modules
{
	push $mod_dir, @INC;

	@mods = < $mod_dir/*.pm >;

	$ln = q( for my $mod (@mods) {require $mod} );
	jail->reval($ln);
}

sub make_animation;

sub process_status {
	for ($status) {
		if (/Teleported to (.*)\/(.*)\/(.*)/) {
			$player->{x} = $portals[$3-1][0] + .5;
			$player->{y} = $portals[$3-1][1] + 1 + $small_value;
			make_animation($player->{x}, $player->{y} - 1, $3, "up");
		}
	}
}

sub save_world;

sub save_all
{
	use Data::Dumper;

	$result = Data::Dumper->Dump([\@objects], ["\*objects"]);
	$result .= Data::Dumper->Dump([\%state], ["\*state"]);
	$result .= Data::Dumper->Dump([$num_objects], ["\*num_objects"]);
	$result .= Data::Dumper->Dump([$player->{id}], ["\*player_id"]);
	$result .= Data::Dumper->Dump([$status], ["\*status"]);
	$result .= Data::Dumper->Dump([$object_created], ["\*object_created"]);
	$result .= Data::Dumper->Dump([\@save_points], ["\*save_points"]);

	save_world $state_file . ".map";

        open STATE, ">$state_file";
        print STATE $result;
        close STATE;
}

sub load_all
{
        open STATE, "<$state_file";
        my $code = join " ", <STATE>;
	$code =~ s/\n//g;
        close STATE;
	eval($code);
	$player = id_to_object($player_id);
	process_status;
}

sub hide_all {
	for my $obj (@objects) {

		$obj->hide();

		# my $spr = $obj->{sprite};
		# if ($spr) {
		#	# print "curses:hide:$spr\n";
		#	$obj->hide();
		# }
	}
}

#reval q(
package Object {
	sub new
	{
		die ("Trying to create abstract object");
	}

	sub init
	{
		my ($self, $x, $y, $w, $h) = @_;

		# Get class name.
		(my $class = $self) =~ s/=.*//;

		$self->{x} = $x;
		$self->{y} = $y;
		$self->{w} = $w;
		$self->{h} = $h;
		$self->{id} = main::get_objects_num();	#scalar @main::objects;
		$self->{type} = $class;
		$self->{alive} = 1;
		$self->{visible} = 1;
	}

	sub hide
	{
		my $self = shift;
		my $sprite = $self->{sprite};

		$self->{visible} = 0;
		print "curses:hide:$sprite\n";
	}

	sub show
	{
		my $self = shift;
		my $sprite = $self->{sprite};

		$self->{visible} = 1;
		print "curses:show:$sprite\n";
	}

	sub low_draw
	{
		my $self = shift;
		my ($x, $y);
		my $sprite = $self->{sprite};

		if (main::obj_on_screen($self)) {
			if (!$self->{visible}) { $self->show }
		} else {
			if ($self->{visible}) { $self->hide }
			return;
		}

		$x  = $self->left;
		my $h = $self->{h};
		my $ry = $self->{y};
		$y = $self->top;

		my $feet_on_top;
		if (main::is_on_screen($x, $ry - 1, $self->{w}, $h)) {
			 $feet_on_top = 1;
		}

		my $x_shift = $main::scr_x;

		$x-=$x_shift;
	#	$y-=$y_shift;

		# $y += 1;


		# for - y's while drawing on screen (feet only)

	#	if ($feet_on_top) {
	#		$y += $self->{h};
	#	}

		# $y -= $small_value;	# Always show a sprite on its 'feet' screen.

		$y -= $main::scr_y;
		#$y = $scrh - $y + 2 * $h;
		$y = $main::scrh - $y;
		$y += $main::floor_shift;

		$x *= $main::tile_width;
		$y *= $main::tile_height;

	#	$x  = $x % ($scrw * $main::tile_width);
	#	$y  = $y % ($scrh * $main::tile_height);

	#	if ($feet_on_top) {
	#		$y -= $self->{h} * $main::tile_height;
	#	}

		$y += 1;
		$x = int $x;
		$y = int $y;

		print "curses:mvs2:$sprite:$x:$y\n";
	}

	sub draw
	{
		my $self = shift;

		$self->low_draw();
		$main::repaint++;
	}

	sub update
	{
		my $self = shift;

		$self->draw();
	}

	sub kill
	{
		my $self = shift;

		$self->hide();
		$self->{alive} = 0;
		# undef $main::objects[ $self->{id} ];
		main::destroy_object($self);
	}
		
	sub left
	{
		my $self = shift;
		return $self->{x};
	}
	
	sub right
	{
		my $self = shift;
		return $self->{x} + $self->{w};
	}
	
	sub top
	{
		my $self = shift;
		return $self->{y} + $self->{h};
	}

	sub bottom
	{
		my $self = shift;
		return $self->{y};
	}
}

package Player {

use parent -norequire, 'Object';

sub new()
{
	my ($class, $x, $y) = @_;
	my $self={};
	bless($self, $class);

	$self->init($x, $y, 1, 2);

	$self->{walkspeed}=@{$main::object{character}{walkspeed}}[0];
	my $i=1;
	for $s (@{$main::object{"character"}{"walk"}})
	{
		print "curses:newspr:character.walk.$i:" . $s . "\n";
		print "curses:newspr:character.walk.$i.+1:" . $s . ".+1\n";
		$i++;
		print "mk loop\n";
	}
	return $self;
}

sub draw
{
	my $self = shift;

	my $walk = $main::walk/2 % 3 + 1;
	$self->{sprite} = "character.walk.$walk"; 
	$self->hideall();
	print "curses:show:$sprite\n";
	$self->low_draw();
}

sub update_v {
	my $self = shift;

	my $x = $self->{x};
	my $y = $self->{y};
	my $w = $main::spr_w;
	my $h = $main::spr_h - $main::fall_dec;

	my $vx = \$self->{vx};
	my $vy = \$self->{vy};

	my $nx = $x + $$vx;
	my $ny = $y + $$vy;

	$self->{new_y} = $ny;

	if ($self->{swim}) {
		$$vy -= $main::fall_dec / 4;
	} else {
		$$vy -= $main::fall_dec;
	}

	# Set when bumps water.
	$self->{swim} = 0;

	if ($$vy) {
		#my $old_vy = $vy;	# For bumping things and riding platforms.

		#if (can_move($x, $ny, $w, $h)) {


		if (main::can_move($x, $ny, $self)) {
			$self->{y} = $ny;
			main::change_screen;
			$main::sprmoved++;
			$main::inair = 1;
		}
		else {
			#this var breaks the game
			$main::inair && ($$vy < 0) &&
				main::fast_fall($nx, $ny);
			$$vy = 0;
		}
	}

	if (1 or $vx) {
		#if (can_move($nx, $y, $w, $h)) {

		if (main::can_move($nx, $y, $self)) {
			$self->{x} = $nx;
			$main::walk += ($vx > 0) ? 1 : -1;
			#change_screen2;
			main::change_screen;
			$main::sprmoved++;
		}	
	}	
}

sub update
{
	my $self = shift;

	my $vx = \$self->{vx};
	my $vy = \$self->{vy};

	print "debug:anim:updmove, alive= $self->{alive}\n";

	$main::sprmoved++;

	$rundec=@{$main::object{character}{walkstop}}[0];

	if (!$main::inair) {
		if ($$vx > $rundec) { 
			$$vx -= $rundec
		} elsif (abs($$vx) > $rundec) {
			$$vx += $rundec
		} else {
			$$vx = 0
		}
	}


#	$other_scr = check_other_screens($nx, $ny, $w, $h);

#	if ($other_scr) {
#		provide_screen($other_scr);
#	}

	if (not $main::climb_mode) {
		$self->update_v();
	}

	if ($self->{x} < 0) { $self->{x} = 0 }
	#if ($self->{y} > $worldh) { $self->kill }
	if ($self->{y} < 0) { $self->kill }
	# elsif ($self->{y} > $main::worldh) { $self->hide }
	else {
		if (!$self->{visible}) { $self->{visible} = 1 }
	}

}

# TODO: Add hide_all to Object class. @sprites.
sub hideall
{
	my $self = shift;
	print "curses:hide:character.walk.1\n";
	print "curses:hide:character.walk.2\n";
	print "curses:hide:character.walk.3\n";
	print "curses:hide:character.walk.1.+1\n";
	print "curses:hide:character.walk.2.+1\n";
	print "curses:hide:character.walk.3.+1\n";
}

sub hide
{
	my $self = shift;
	my $i=1;
	$self->{visible}=0;
	for $s (@{$main::object{"character"}{"walk"}})
	{
		print "curses:hide:character.walk.$i:" . $s . "\n";
		print "curses:hide:character.walk.$i.+1:" . $s . ".+1\n";
		$i++;
	print "hide loop\n";
	}
}

sub kill()
{
	my $self = shift;
	$self->{y}=$worldh;
	$self->{x}=3;
	# You don't actually kill the player object.
	# undef $main::objects[ $self->{id} ];
}


1;
}


package BrokenBrick {

use parent -norequire, 'Object';

sub new
{
	my ($class, $x, $y) = @_;
	my $self={};
	bless($self, $class);

	$self->init($x, $y, 1, 1);

	my $id = $self->{id};
	$self->{vx}=.3;
	$self->{vy}=.3;
	$id = $id % 4 + 1;	# Sprite names are 1 through 4.
	$self->{sprite}="broken_brick_$id";
	$self->{vx} *= ($id & 1) ? 1 : -1;
	$self->{vy} *= ($id & 2) ? 1 : -1;
	$self->{x} += 2 * $self->{vx};
	$self->{y} += 2 * $self->{vy};

	return $self;	
}

sub update
{
	my $self = shift;
	$self->{vy} -= $main::fall_dec;
	$self->{y} += $self->{vy};
	$self->{x} += $self->{vx};
	$self->draw();
	if ($self->{y} < 0) {
		$self->kill();
	}
}

1;
}

package Enemy {

use parent -norequire, 'Object';

sub new
{
	my ($class, $x, $y)=@_;
	
	my $self={};
	bless($self, $class);

	$self->init($x, $y, 1, 1);

	$self->{gravity}=0;
	$self->{vx} += @{$main::object{"klop"}{"move"}}[0];

	# $self->{move}+=@{$main::object{"klop"}{"move"}}[0];

#	my $i=0;
#	for $s (@{$main::object{"klop"}{"walk"}})
#	{
#		print "curses:newspr:klop" . $self->{id} . ".walk.$i:" . $s 
#			. "\n";
#		$i++;
#		print "mkklop\n";
#	}

	print "curses:newspr:bird_wing_up_left" . $self->{id} . ":bird_wing_up_left\n"; 
	print "curses:newspr:bird_wing_up_right" . $self->{id} . ":bird_wing_up_right\n"; 
	print "curses:newspr:bird_wing_down_left" . $self->{id} . ":bird_wing_down_left\n"; 
	print "curses:newspr:bird_wing_down_right" . $self->{id} . ":bird_wing_down_right\n"; 

	$self->hide();

	return $self;
}

sub hide_all
{
	print "hide klop\n";
	my $self = shift;
	$self->{visible}=0;
	print "curses:hide:klop" . $self->{id} . ".walk.0\n";
	print "curses:hide:klop" . $self->{id} . ".walk.1\n";
	print "curses:hide:klop" . $self->{id} . ".walk.0.+1\n";
	print "curses:hide:klop" . $self->{id} . ".walk.1.+1\n";
	print "curses:ref\n";
}

sub update
{
	print "update klop\n";
	my $self = shift;
	my $x = $self->{x};
	my $y = $self->{y};
	my $h = $self->{h};
	my $w = $self->{w};

	if ($x<-$w) { $self->kill(); return }
	if ($y>$main::worldh) { $self->kill(); return }

	# my $nx = $x + $self->{move};
	my $nx = $x + $self->{vx};
	my $ny = $y + $self->{vy};

	if ($self->{gravity}) {
		$ny -= $main::fall_dec;
	}

	$self->{turned} = 0;

	#if (main::can_move($nx, $y+$main::pixel_height-$h, $main::spr_w, $h-$main::pixel_height, True)) {
	#if (main::can_move($nx, $y+$main::pixel_height, $main::spr_w, $h-$main::pixel_height, True)) {

	# TODO: If there are bugs, uncomment this and use y_plus instead of y.
	# my $y_plus = $y;
	# if ($self->{gravity}) {
	#	$y_plus += $main::small_value;
	# }

	if (main::can_move($nx, $y, $self)) {
		if (not $self->{turned}) {
			$self->{x}=$nx;
		}
	} else {
		$self->{vx} *= -1;
		print "klop cant move: $x, $y while mario is at $a, $b\n";
	}


	#if (main::can_move($x, $ny+$main::pixel_height-$h, $main::spr_w, $h-$main::pixel_height, True)) {
	#if (main::can_move($x, $ny+$main::pixel_height, $main::spr_w, $h-$main::pixel_height, True)) {


	if (main::can_move($x, $ny, $self)) {
		if (not $self->{turned}) {
			$self->{y}=$ny;
		}
	}

	print "Drawing klop: $x, $y\n";
	$self->draw();	
}
1;
}

package Klop {
	use parent -norequire, 'Enemy';
sub new
{
	my ($class, $x, $y)=@_;
	
	my $self = {};
	bless($self, $class);

	$self->init($x, $y, 1, 1);

	$self->{gravity} = 1;
	$self->{vx} += @{$main::object{"klop"}{"move"}}[0];

	# $self->{move}+=@{$main::object{"klop"}{"move"}}[0];

	my $i = 0;
	my $id = $self->{id};
	for $s (@{$main::object{"klop"}{"walk"}})
	{
		print "curses:newspr:klop_$id.walk.$i:$s\n";
		$i++;
		print "mkklop\n";
	}
	$self->hide();

	return $self;
}

sub draw {
	my $self = shift;
	my $id = $self->{id};

	if ($self->{visible}) {
		my $num_walk=@{$main::object{"klop"}{"walk"}};
		my $walk=( $main::tile_width * $self->{x} ) % $num_walk;

		$self->{sprite} = "klop_$id.walk.$walk";

		for (my $nwalk=0; $nwalk<$num_walk; $nwalk++) {
			if ($nwalk == $walk) {
				print "curses:show:klop_$id.walk.$nwalk\n";
			} else {
				print "curses:hide:klop_$id.walk.$nwalk\n";
				print "curses:hide:klop_$id.walk.$nwalk.+1\n";
			}
			print "paint klop\n";
		}
	}
	$self->SUPER::draw();
}

1;
}

package Bird {
	use parent -norequire, 'Enemy';

sub draw {	
	my $self = shift;
	my $id = $self->{id};

	$self->{sprite} = "bird_";
	$self->hide_all();

	if (($self->{x} * $main::tile_width) % 2) {
		$self->{sprite} .= "wing_up_";
	} else {
		$self->{sprite} .= "wing_down_";
	}

	if ($self->{vx} >= 0) {
		$self->{sprite} .= "right" . $id;
	} else {
		$self->{sprite} .= "left" . $id;
	}
	$self->SUPER::draw();
}

sub hide_all
{
	my $self = shift;
	my $id = $self->{id};
	$self->{visible}=0;

	print "hide bird\n";

	print "curses:hide:bird_wing_up_left" . $id . "\n";
	print "curses:hide:bird_wing_up_right" . $id . "\n";
	print "curses:hide:bird_wing_down_left" . $id . "\n";
	print "curses:hide:bird_wing_down_right" . $id . "\n";
#	print "curses:ref\n";
	$main::repaint++;
}

1;
}

package Platform_4 {
	use parent -norequire, 'Enemy';
sub new
{
	my ($class, $x, $y)=@_;
	
	my $self={};
	bless($self, $class);

	$self->init($x, $y, 3, 1);

	$self->{gravity}=0;
	$self->{sprite}="platform_4_" . $self->{id};
	$self->{vx} += @{$main::object{"klop"}{"move"}}[0];

	# $self->{move}+=@{$main::object{"klop"}{"move"}}[0];

	my $i=0;

#	for $s (@{$main::object{"klop"}{"walk"}})
#	{
#		print "curses:newspr:klop" . $self->{id} . ".walk.$i:" . $s 
#			. "\n";
#		$i++;
#		print "mkklop\n";
#	}

	print "curses:newspr:platform_4_" . $self->{id} . ":platform_4\n"; 

	$self->hide();

	return $self;
}

1;
}

# not used, delete
package Portal_Down {
sub new
{
	my ($class, $x, $y) = @_;
	my $self={};
	bless($self, $class);
	#my $id = scalar @main::objects;
	my $id = main::get_objects_num();
	$self->{x}=$x;
	$self->{y}=$y;
	$self->{id}=$id;
	return $self;
}

1;
}

package AnimationDive {

use parent -norequire, 'Object';

sub new
{
	my ($class, $x, $y) = @_;
	my $self={};
	bless($self, $class);
	#my $id = scalar @main::objects;
	my $id = main::get_objects_num();
	$self->{x}=$x;
	$self->{y}=$y;
	$self->{h}=2;
	# $self->{oy}=$y;
	# $self->{dest_y}=$y - 2;
	$self->{id}=$id;
	$self->{alive}=1;
	$self->{type}=$class;
	$self->{visible}=1;
	# $main::world[i][]

	return $self;
}

sub update {
	my $self = shift;
	my $dec = .05;
	my $recip = 1 / $dec;

	print "debug:anim:upd\n";

	my $fract = $self->{x} - int $self->{x};
	my $diff = .5 + $dec - $fract;

	my $sign = $diff > 0 ? -1 : 1;

	if (abs($diff) > $dec) {
		$self->{x} -= $dec * $sign;
	}

	my $new_y = $self->{y} + $dec * $self->{direct};
	my $diff_y = $new_y - $self->{dest_y};

	if (abs($diff_y) > $dec ) { 
		$self->{y} = $new_y;
		print "y=", $self->{y}, "\n";
		$self->draw();
	} else {
		$self->{on_done}($self);
	}
}

sub draw {
	my $self = shift;
	print "debug:anim:draw y=$self->{y}\n";

	my $walk = $main::walk/2 % 3 + 1;

	$self->{sprite} = "character.walk.$walk"; 
	$self->low_draw();

	# $self->hideall();
	# print "curses:show:$self->{sprite}\n";
	# my ($x, $y) = (int $self->{x}, int $self->{y}); 
	# print "curses:mvs2:$sprite:$x:$y\n";

	my $spr = $self->{sprite};
	my ($rx, $ry) = ($self->{x}, $self->{y});

#	print "curses:show:over\n";
	$self->{sprite} = "over";

	($self->{x}, $self->{y}) = ($self->{over_x}, $self->{over_y});
	#($self->{x}, $self->{y}) = ($self->{over_x}+1/8*(8*$self->{y}%2), $self->{over_y});

	$self->low_draw();

	$self->{sprite} = $spr;
	($self->{x}, $self->{y}) = ($rx, $ry);

#	print "curses:to_top:over\n";


	#print "curses:ref\n";

	$main::repaint = 1;
}

1;
}

#);

sub set_alarm()
{
	$SIG{ALRM}=\&update; Time::HiRes::ualarm($pdelay);
}

sub unset_alarm()
{
	undef $SIG{ALRM};
	Time::HiRes::ualarm(0);
}

# not used, remove
sub load_screen
{
	my ($scr) = @_;

	unset_alarm();
	draw_world($scr->{x}, $scr->{y}, True);
	if ($object_created) {
		set_alarm();
	}
}

sub change_screen
{

	$old_scr_x = $scr_x;
	$old_scr_y = $scr_y;

	change_screen2;

	if ($scr_x != $old_scr_x or $scr_y != $old_scr_y){
		unset_alarm();
		draw_world;
		if ($object_created) {
			set_alarm();
		}
		return 1
	}

	return 0
}

sub gettypes
{
	$k = $_[0];
	@k2 = split(/\s+/, $types3{$k});	
	return @k2;
}

#TODO: ADD THESE IN CODE!!!
#curses:hide:sprf
#curses:progsprinc:load


sub cat_file
{
	my $file=$_[0];

	print "debug_:$file\n";
	my @lines=`cat $file`;
	for my $line (@lines) { print $line }

	# or just system("cat $file");
	return @lines;
}

sub load_config
{
	open CONF, "<$_[0]";
	my @conf=<CONF>;
	close CONF;
	return @conf;
}

sub load_logo {
	my $logo_file = $ENV{LOGO} || "logo.crs";
	my @logo=cat_file($logo_file);		

	$logo[0] =~ /spr:logo:([^:]+):([^:]+)/;
	my $lx = int (($tile_width * $scrw-$1)/2);
	my $ly = int (($tile_height * $scrh-2*$2)/2);
	print "curses:mvs2:logo:$lx:$ly\n";
	print "curses:ref\n";
}

sub def_types {
	my (%legend) = @_;
	print "legend=", %legend, "\n";
	print "legend keys=", keys %legend, "\n";
	for my $type (keys %legend) {
		for my $field (@{$legend{$type}}) {

			print "type=$type; field=$field\n";
			if ($field eq "obst") {
				push @obst, $type;
			} elsif ($field eq "brick") {
				push @brick, $type;
			} elsif ($field =~ /^show=(.*)/) {
				$t_show{$type} = $1;
				if ($t_show{$type} eq "") {
					$t_show{$type} = " ";
				}
				print "type=$type; field=$field match $t_show{$type}=$1\n";
			} elsif ($field eq "water") {
				push @t_water, $type;
			} elsif ($field eq "klop") {
				push @t_klop, $type;
			} elsif ($field eq "bird") {
				push @t_bird, $type;
			} elsif ($field eq "box") {
				push @box, $type;
			} elsif ($field eq "coin") {
				push @coin, $type;
			} elsif ($field eq "climb") {
				push @t_climb, $type;
			} elsif ($field eq "turn") {
				push @t_turn, $type;
			} elsif ($field eq "left_turn") {
				push @t_left_turn, $type;
			} elsif ($field eq "right_turn") {
				push @t_right_turn, $type;
			} elsif ($field eq "save") {
				push @t_save, $type;
			} elsif ($field eq "portal_down") {
				push @portal, $type;
			} elsif ($field eq "platform_4") {
				push @t_platform_4, $type;
			} elsif ($field eq "player") {
				push @t_player, $type;
			} else {
				print "type=$type; field=$field error $t_show{$type}\n";
				push @t_error, $type;
				$t_show{$type} = " ";	# To draw attention.
			}
		}
		if (not $type ~~ [@obst, @brick, @box, @coin, @t_save, @portal, keys %t_show, @t_water]) {
			push @t_walk, $type;
		}
	}
}

sub load_legend {
	my $legend_file = $ENV{LEGEND} || "level.legend";
	my @types2 = load_config "$legend_file";
	for (@types2)
	{
		if (/^\s*\/\//) { next }
		if (/^(.)\s*=\s*(.*)/) {
			$types3{$1} = $2;
		}
	}
	for my $k (keys %types3) {
		@types4{$k} = [gettypes($k)]; #FIXME WHY???
	}

	def_types(%types4);
}

sub load_objects_config {
	my $objects_file = $ENV{OBJECTS} || "objects.txt";
	my @obj = load_config "$objects_file";
	for (@obj)
	{
		if (/^\s*\/\//) { next }
		if (/^\s*(\S+)\.(\S+)\s*=\s*(.*)/) {
			@{$object{$1}{$2}} = split(/\s+/, $3);
		}
	}
}

sub mkworld
{
	load_logo;
	cat_file("sprites.crs");		
	load_legend;
	load_objects_config;
}

# Not used.
sub check_sqr_pt
{
	my ($sx, $sy, $sex, $sey, $px, $py)=(@_);
	if ( ($px>$sx && $px<$sex) && ($py>$sy && $py<$sey) ) {
		return 1;
	}

	return 0;
}

# Not used.
sub check_squares2
{
	my ($sx, $sy, $ex, $ey, $sx2, $sy2, $ex2, $ey2) = @_;

	if (($sx > $ex2)	# Too right.
	 or ($ex < $sx2)	# Too left.
	 or ($sy > $ey2)	# Too high.
	 or ($ey < $sy2)) {	# Too low. Is this line needed?
		return 0;
	}

	return 1;
}

sub go_to_save_point {
	if (not @save_points) {
		return 0;
	}
	$player->{x} = (split "/", $save_points[-1])[1];
	$player->{y} = (split "/", $save_points[-1])[2];

	return 1;
}

sub block_touched {
	my ($i, $j, $obj) = @_;
	# True if (previous) x,y are not in the sqare.

	if ((int($obj->{x}) != $i)
	 or (int($obj->{x} + $obj->{w}) != $i)
	 or (int($obj->{y}) != $j)
	 or 0 and (int($obj->{y} + $obj->{h}) != $j)) { # Is this line needed?
		return 1;
	}

	return 0;
}

# Not used.
sub block_touched2 {
	my ($sx, $sy, $obj) = @_;
	my $ox = $obj->{x};
	my $oy = $obj->{y};
	my $ow = $obj->{w};
	my $oh = $obj->{h};
	my $sw = 1;
	my $sh = 1;
	my $oex = $ox + $ow;
	my $oey = $oy + $oh;
	my $sex = $sx + $sw;
	my $sey = $sy + $sh;

	if (($ox > $sex)		# Too right.
	 or ($oex < $sx)	# Too left.
	 or ($oy > $sey)		# Too high.
	 or ($oey < $sy)) {	# Too low. Is this line needed?
		return 0;
	}

	return 1;
}

sub do_tile_action {
	my ($obj, $i, $j) = @_;
	my $sqr = get_sprite($i, $j);

	if ($obj->{type} eq "Player") {
		# Or check by coordinates that can be found before.
		if ($sqr ~~ @t_save) {
			my $save_point = "$level_name/$i/$j";
			for (@save_points) {
				# Already added.
				if ($_ eq $save_point) {
					return 1;
				}
			}
			push @save_points, $save_point;

			return 1;
		}
	} else {
		if ($sqr ~~ @t_turn) {
			if (block_touched($i, $j, $obj)) {
				print "debug:u_turn: old ", $obj->{vx}, $obj->{vy}, "\n";
				print "debug:u_turn: old ", $obj->{x}, $obj->{y}, "\n";
				$obj->{turned} = 1;
				$obj->{vx} *= -1;
				$obj->{vy} *= -1;
				# $obj->{x} += $obj->{vx};
				#$obj->{y} += $obj->{vy};
				print "debug:u_turn: new ", $obj->{vx}, $obj->{vy}, "\n";
				print "debug:u_turn: new ", $obj->{x}, $obj->{y}, "\n";
				return 1;

			}

		} elsif ($sqr ~~ @t_left_turn) {
			if (block_touched($i, $j, $obj)) {
				my $tmp;
				print "debug:left_turn: old ", $obj->{vx}, $obj->{vy}, "\n";
				print "debug:left_turn: old ", $obj->{x}, $obj->{y}, "\n";
				$obj->{turned} = 1;
				$tmp = $obj->{vy};
				$obj->{vy} = $obj->{vx};
				$obj->{vx} = -$tmp;

				print "debug:left_turn: new ", $obj->{vx}, $obj->{vy}, "\n";
				print "debug:left_turn: new ", $obj->{x}, $obj->{y}, "\n";
				
				return 1;
				
			}
		} elsif ($sqr ~~ @t_right_turn) {
			if (block_touched($i, $j, $obj)) {
				my $tmp;
				print "debug:left_turn: old ", $obj->{vx}, $obj->{vy}, "\n";
				print "debug:left_turn: old ", $obj->{x}, $obj->{y}, "\n";
				$obj->{turned} = 1;
				$tmp = $obj->{vy};
				$obj->{vy} = $obj->{vx};
				$obj->{vx} = -$tmp;

				print "debug:left_turn: new ", $obj->{vx}, $obj->{vy}, "\n";
				print "debug:left_turn: new ", $obj->{x}, $obj->{y}, "\n";
				
				return 1;
				
			}
		}
	}
	if ($sqr ~~ @t_walk) {
		return 1;
	} elsif ($sqr ~~ @obst) {
		return 0;
	} elsif ($sqr ~~ @t_water) {
		$player->{swim} = 1;
		return 1;
	} elsif ($sqr ~~ @brick) {

		#my $plr_to_btm=$objy - $j -1;
		#print "brick:j=$j; y=$objy dist=$plr_to_btm\n";
		#if ($vy > 0 && $plr_to_btm < .5) {
		#FIXME: This assumes p->{w} == brick->w == 1
		#print "brick: i=$i; x=$objx dist=$plr_to_btm\n";

		my $obj_top = int($obj->{new_y} + $obj->{h});
		if ($obj->{vy} > 0
		     and $obj->{type} eq "Player"
		     and $obj_top == $j) {
			$world[$i][$j]="\"";
			my $x = $i + .5;
			my $y = $j  + .5;

			for (my $i=0; $i<4; $i++) {
				create_object($x, $y, 
					"BrokenBrick");
			}

			draw_world;
			return 0;
		} else {
			return 0;
		}
		
	} elsif ($sqr ~~ @box) {
		if ($obj->{vy} > 0 && !$obj_is_klop) {
			create_object($i, $j + 1, "Klop");
			$world[$i][$j]="Z";
			draw_world;
		}
		return 0;
	} elsif ($sqr ~~ @coin) {
		if (!$obj_is_klop) {
			$coins++;
			$world[$i][$j]="\"";
			draw_world;
		}
		return 1;
	} elsif ($sqr ~~ @one_way_wall) {
		# This type may be used in the future. 
		if ($obj->{vy} < 0) {
			return 0;
		}
	}
	print "can move 1\n";
}

sub can_move
{
	my ($objx, $objy, $obj) = @_;
	my $objw=$obj->{w};
	my $objh=$obj->{h};
	#my ($objx, $objy, $objw, $objh, $obj_is_klop) = @_;
#	$objy-=1;
#	return 1;
	my $leftsqr=int($objx);

	# This weird math is legit for bumping into things from the left.
	my $rightsqr=int($objx + $objw - $small_value + 1);

	my $topsqr=int($objy);
	my $botsqr=int($objy + $objh);
	#my $botsqr=int($objy + $objh - $pixel_height);
	($botsqr, $topsqr) = ($topsqr, $botsqr);

	for (my $i=$leftsqr; $i<$rightsqr; $i++) {
		for (my $j=$botsqr; $j<=$topsqr; $j++) {
			#my $sqr=$world[$i][$j];
			if (do_tile_action($obj, $i, $j)) {
				next;
			} else {
				return 0;
			}
		}
	}

	if ($obj->{type} eq "Player") {
		my $oex=$objx + $objw;
		my $oey=$objy + $objh;
		my $ox=$objx;
		my $oy=$objy;

		for my $k (@objects) {
			print "k=$k\n";
			if (!$k->{alive}) { next }

			if (($k->{type} ne "Klop") and
			    ($k->{type} ne "Bird") and
			    ($k->{type} ne "Platform_4")) {
				next;
			}

			print "can move 2 $a, $b\n";
			my $kx=$k->{x};
			my $ky=$k->{y};
			my $kex=$kx + $k->{w};
			my $key=$ky + $k->{h};

			if ( check_squares2($ox, $oy, $oex, $oey,
			                   $kx, $ky, $kex, $key) ) {
				if ($k->{type} eq "Platform_4") {
					# TODO:
					# $obj->{vx} = $k->{vx};
					# $obj->{vy} = $k->{vy};

					$obj->{vx} = $k->{vx} * 2;
					$obj->{vy} = $k->{vy} * 2;
					$obj->{y} += $k->{vy};

					return 0;
				} else {
					if ($inair and $obj->{vy} < 0) {
						$score++;
						$k->kill;
						$obj->{vy} /= -2;
					} else {
						$player->kill();
					}
				}
			}
		}
	} elsif (False) { 		#FIXME: old coords
		my $oex=$objx+$objw;
		my $oey=$objy+2*$objh;
		my $ox=$objx;
		my $oy=$objy;

			#$k=mario
			#if (!$k->{alive}) { next }

			my $kx=$a;
			my $ky=$b;
			my $kex=$kx+$psprw;
			my $key=$ky+$psprh;

			if ( check_squares2($ox, $oy, $oex, $oey,
			              $kx, $ky, $kex, $key) ) {
				if ($inair && $vy<0) {
					killklop $k;
					$vy/=-2;
				} else {
					$player->kill;
				}
			}
		
	}

	return 1;
}

# not used
sub provide_screen
{
	my ($scr_a) = @_;
	my $scr = $scr_a->{x} . "," . $scr_a->{y};
	
	# The game slows down when load_screen is called indiscriminately.
	# This might mean there are leaks / unkilled objs updating.

	if (not $scr ~~ @loaded_screens) {
		load_screen($scr_a);
		push @loaded_screens, $scr;
	}
}

# not used, remove
sub check_other_screens
{
	my ($x, $y, $w, $h) = @_;

	my %r_scr;

	$r_scr->{x} = $nscr;
	$r_scr->{y} = $nscry;

	my $ret_x;
	my $ret_y;

	my $scr_x_seft = onscr2($x);
	my $scr_x_right = onscr2($x + $w);
	my $scr_y_top = onscry2($y + $h);
	my $scr_y_bottom = onscry2($y);

	if ($scr_x_right > $nscr) {
		$r_scr->{x} = $scr_x_right;
		$ret_x = 1;
	} elsif ($scr_x_seft < $nscr) {
		$r_scr->{x} = $scr_x_seft;
                $ret_x = 1;
	}

        if ($scr_y_bottom < $nscry) {
                $r_scr->{y} = $scr_y_bottom;
                $ret_y = 1;
        } elsif ($scr_y_top > $nscry) {
                $r_scr->{y} = $scr_y_top;
                $ret_y = 1;
        }

	if ($ret_x or $ret_y) {
		return $r_scr;
	}
}

sub fast_fall
{
	my ($na, $nb) = @_;

	# For falling down and bumping stones.
	#$vy = ($vy<0) ? -$pixel_height : $pixel_height; 
	$player->{vy} = -$fall_dec;
	
	#for (my $i=0; $i<1000; $i++) {

	while (True) {
		$nb = $player->{y} + $player->{vy};
		print "fast fall loop $a, $b\n";


		#if (can_move($player->{x}, $nb, $spr_w, $spr_h-$pixel_height)) {


		if (can_move($player->{x}, $nb, $player)) {
			$player->{y} = $nb;
			change_screen;
			$sprmoved++;
		}
		else {
			$player->{vy} = 0;
			$inair = 0;
			last;
		}
	}
	if ($auto_floor_shift) {
		set_floor_shift;
	}
}

sub update_all_objects
{
	#reval q(
	for my $o (@objects) {
		if ($o->{alive}) { 
			$o->update();
		}
	}
	#);
}

sub update
{
	my $mutex_all;
	lock $mutex_all;

	print "upd\n";

	$in_lock = 1;

	if ($race) {
		$scr_shift++;

		if ($scr_shift >= 5 * $tile_height) {
			$scr_shift = 0;
		}
		print "curses:mvs2:backdrop:0:$scr_shift\n";

	}

	update_all_objects();

	if ($sprmoved) {
		$sprmoved=0;
		if ($object_created){
			#reval q(
			$player->{visible} && $player->draw();
			#);
		}
		$repaint=1;
	}
	if ($repaint) {
		print "curses:ref\n";
		# Prevent jerkiness.
		flush STDOUT;
		$repaint=0;
	}
	print_score;
	print_pl_coord;
	set_alarm();
	#unlock $mutex_all;
	$in_lock = 0;
}

sub load_world
{
	my ($x, $y, @map, $map_file, $line);
	if (-e $state_file) {
		$map_file = $state_file . ".map";
	} else {
		$map_file = $ENV{MAP_FILE} || "level.map";
	}
	open(F, "<$map_file");
	@map = <F>;
	close F;
	@map = grep /^.+$/, @map;
	$world_h = @map;
	for ($y = 0; $y < $world_h; $y++) {
		$line = $map[$world_h - $y -1];
		chomp $line;
		for ($x=0; 1; $x++) {
			my $val = substr $line, $x, 1;

			if ($x > $world_w) {
				$world_w = $x;
			}

			if ($x == length $line) {
				$x--; # We shouldn't've run this time, so no ++.
				last;
			} else {
				$world[$x][$y] = $val;
			}
		}
	}
	$worldh = $world_h;
}

sub save_world {
	my ($map_file) = @_;
	my ($x, $y);

	open(F, ">$map_file");
	for ($y = $world_h-1; $y >=0; $y--) {
		for ($x=0; $x < $world_w; $x++) {
			print F $world[$x][$y];
		}
		print F "\n";
	}
	close F; 
}

sub draw_square
{
	my ($x, $y, $spr_type) = @_;

	for (@{$types4{$spr_type}}) {
		if ($_ eq "hide") { next }
	}

	if (defined $t_show{$spr_type}) {
		$spr_show = $t_show{$spr_type};
	} else {
		$spr_show = $spr_type;
	}

	my $sx=$x-$scr_x;
	my $sy=$y-$scr_y;

	print "ultradebug: sx=$sx, sy=$sy, sy2=$sy2, type=$sprtype\n";

	print "debug: i=$x, j=$y, sy=$sy\n"; 
	$sy=$scrh-$sy-1;

	$sx *= $tile_width;
	$sy *= $tile_rows;
	
	# Print coords at their pos, not at sprite origin.
	$dsy = $sy + $tile_height/2 - 1;

	print "curses:paste:backdrop:spr$spr_show:0:0:$sx:$sy:$tile_width:$tile_rows\n";
	if ($show_coords) {
		my $char;
		$y += $floor_shift;
		if ($show_constr_bar) {
			$char = $spr_type;
			print "curses:prc:backdrop:$sx:" . ($dsy - 1) . ":7:0:$char\n";
		}
		print "curses:prc:backdrop:$sx:$dsy:7:0:$x,$y\n";
	}
}

sub create_object
{
	my ($x, $y, $type) = @_;
	my $o = $type->new($x, $y);
	$num_objects++;
	push @objects, $o;

	return $o;
}

sub create_object_once
{
	my ($x, $y, $type) = @_;
	my $obj;

	if (defined $state{"$x,$y"}) {
		my $id = $state{"$x,$y"};
		$obj = $objects[$id]; 
	} else {
		$obj = create_object($x, $y, $type);
		$state{"$x,$y"} = $obj->{id};
	}

	return $obj;
}

sub load_square
{
	my ($x, $y, $type) = @_;

	print "debug: loading sqr $x $y\n";
	#for (@{$types4{$type}}) {
		if ($type ~~ @t_klop) {
			create_object_once($x, $y, "Klop");
			#print "loading klop at $x,$y\n";
		} 
		elsif ($type ~~ @t_bird) {
			create_object_once($x, $y, "Bird");
		}
		elsif ($type ~~ @t_platform_4) {
			create_object_once($x, $y, "Platform_4");
		}
		elsif ($type ~~ @t_player) {
			print "debug: player created\n";
			$player = create_object_once($x, $y, "Player");
			# start updating only when player has spawned
			update;
			$object_created++;
		}
		print "type loop\n";
	#}
}

sub get_sprite
{
	my ($x, $y) = @_;

	my $spr_type = $world[$x][$y] // $world[0][0];

	return $spr_type;
}

sub get_what_on_screen
{
	my $start_x = $scr_x; 
	my $end_x = $start_x + $scrw;
 
	my $start_y = $scr_y; 
	my $end_y = $start_y + $scrh;

	print "s:$start_y e:$end_y\n";

	return $start_x, $start_y, $end_x, $end_y;
}

sub draw_world
{
	my ($lscr_x, $lscr_y, $don_t_draw) = @_;
	# $lscr_x, $lscr_y are not used.

	print "loading screen x=$scr_x; y=$scr_y\n";

	my ($start_x, $start_y, $end_x, $end_y)
		= get_what_on_screen();

	for (my $x=$start_x; $x < $end_x; $x++) {
		for (my $y=$start_y; $y < $end_y; $y++) {
			my $spr_type = get_sprite($x, $y);
			
			load_square($x, $y, $spr_type);

			$spr_type = get_sprite($x, int($y - $floor_shift));
			if (not defined $don_t_draw) {
				draw_square($x, $y, $spr_type);
			}
			print "sqr loop\n";
			print "sqr: j=$y\n";
		}
	}
}


sub init_srv
{
	my $sprw = $spr_w * $tile_width;
	my $sprh = $spr_h * $tile_height;

#	print "curses:cstart:1\n";
#	print "curses:cstop\n";

	print "curses:init:1\n";
	print "curses:clear\n";
#	print "curses:lnmode:1\n";
#	print "curses:progspr:load:$origsprs\n";
	print "curses:spr:walk1:$sprw:$sprh\n";
	print "curses:spr:walk2:$sprw:$sprh\n";
	print "curses:spr:walk3:$sprw:$sprh\n";
	print "curses:spr:walk1.+1:$sprw:$sprh\n";
	print "curses:spr:walk2.+1:$sprw:$sprh\n";
	print "curses:spr:walk3.+1:$sprw:$sprh\n";
#	print `bash -c 'cd \`dirname $0\`; cat data/*.crs'`;
}

sub find_spawn_point
{
	my $pl_char="|";
	my ($x, $y);
	for ($x=0; $x<=$world_w; $x++) {
		for ($y=0; $y<=$worldh; $y++) {
			print "x=$x,y=$y, " . $world[$x][$y] . "\n";
			if ($world[$x][$y] eq $pl_char) {
				return $x, $y;
			}
		}
	}
	
	print "no fnd\n";
	print "x=$x,y=$y, " . $world[$x][$y] . "\n";
	die("No spawn point on map\n");
}

sub find_type {
	my ($x, $y, @res);
	my @class = @{$_[0]};
	for ($x=0; $x<=$world_w; $x++) {
		for ($y=0; $y<=$worldh; $y++) {
			print "x=$x,y=$y, " . $world[$x][$y] . "\n";
			if ($world[$x][$y] ~~ @class) {
				push @res, [$x, $y];
			}
		}
	}
	return @res;
}

sub make_animation {
	my ($x, $y, $i, $direct) = @_;
	$x = int $x;
	$y = int $y;
	my $id = $player->{id};
	my $anim = create_object($player->{x}, $y + 1, "AnimationDive");
	my ($spr0, $spr1, $spr2, $spr3);
	# $objects[$id] = $anim;
	$anim->{object} = $player;
	$anim->{direct} = $direct eq "up" ? 1 : -1;
	$anim->{depart} = $i; #	Or use eval.
	$player->{alive} = 0;
	if ($direct eq "down") {
		$anim->{dest_y} = $y - 2 + 1;
		$anim->{on_done} = sub {
			my ($anim2) = @_;
	
			$status = "Teleporting from $level_name/pipe/$anim2->{depart}";
			$player = $anim2->{object};
			main::destroy_object($anim2);
			save_all;
			hide_all;
			print "curses:hide:over\n";
			print "curses:del_sprite:over\n";
			exit 1;
		};
	} else {
		$anim->{dest_y} = $y + 1;
		$anim->{y} = $y - 2 + 1;
		$anim->{on_done} = sub {
			my ($anim2) = @_;

			$player = id_to_object $anim2->{object}->{id};
			$player_id = $anim2->{object}->{id};
			print "curses:hide:over\n";
			destroy_object($anim2);
			$player->{alive} = 1;
		};
	}
	$spr0 = $world[$x][$y];
	$spr1 = $world[$x][$y - 1];
	$spr2 = $world[$x + 1][$y];
	$spr3 = $world[$x + 1][$y - 1];

	print "curses:spr:over:" . $tile_width * 2 . ":" . $tile_rows * 2 . "\n";
	print "curses:paste:over:spr$spr0:0:0:0:0:$tile_width:$tile_rows\n";
	print "curses:paste:over:spr$spr1:0:0:0:4:$tile_width:$tile_rows\n";
	print "curses:paste:over:spr$spr2:0:0:8:0:$tile_width:$tile_rows\n";
	print "curses:paste:over:spr$spr3:0:0:8:4:$tile_width:$tile_rows\n";
	print "curses:show:over\n";

	$anim->{over_x} = $x; 
	$anim->{over_y} = $y - 1;
	$player = $anim;
	# $player_id = $player->{id};
}

sub init_jail
{
	$compartment->share("\$player");
	$compartment->share("\@objects");
	$compartment->share("get_objects_num");
	$compartment->share("low_draw");
	$compartment->share("destroy_object");
	$compartment->share("\$tile_width");
	$compartment->share("\$tile_height");
	$compartment->share("\$repaint");
	$compartment->share("\$pixel_height");
	$compartment->share("\$fall_dec");
	$compartment->share("\$small_value");
	$compartment->share("\$spr_w");
	$compartment->share("is_on_scr_y");
	$compartment->share("\%object"); # check types !!
	$compartment->share("\$walk");
	$compartment->share("\$worldh");
	$compartment->share("can_move");
}

sub spawn_player
{
	print "search\n";
	my ($x, $y) = find_spawn_point();
	$player->{x} = $x;
	$player->{y} = $y;
	change_screen;
	print "/search $x; $y\n";
}

sub load_objects {
	push @INC, "./modules/";
	my @m = `ls | sed -n "s/\\.pm\$//p"`;
	for my $m (@m) {
		chomp $m;
		load_object($m);
	}
}

sub size_init
{
	$inited=1;
	mkworld;
	load_world;

	load_objects;

	@portals = find_type( [ "@", "n", "u" ] );

	load_all;

	if (defined $player_id or $dont_spawn) {
		$object_created = 1;
	} else {
		spawn_player;
	}

	#change_screen;
	print "scr_dims $scrw; $scrh\n";

	draw_world;
	make_score_bar;
	print_pl_coord;

	init_jail;

	print "curses:hide:logo\n";
}

sub can_climb {
	my $x = int $player->{x};
	my $y = int($player->{y} + $small_value);

	for (my $i=$x; $i<$x+$player->{w}+1; $i++) {
		for (my $j=$y; $j<$y+$player->{h}+1; $j++) {
			if ($world[$i][$j] ~~ @t_climb) { 
				$inair = 0;
				$climb_mode = 1;
				return 1;
			}
		}
	}
	$climb_mode = 0;
	return 0;
}

sub process_key
{
	$_=$_[0];
	if (/a/) {
		if ($climb_mode) {
			if (can_climb) {
				my $nx = $player->{x} - 1/8;
				my $y = $player->{y};

				if (can_move($nx, $y, $player)) {
					$player->{x} = $nx;
					change_screen;
					$sprmoved++;
				}
			}
		} else {
			$vx = $player->{vx};

			$vx -= $player->{walkspeed};

			if ($vx < -$player->{walkspeed} or $inair) {
				$vx = -$player->{walkspeed};
			}

			$player->{vx} = $vx;

		}

		print "debug: posx=" . $player->{x} . "\n";
		print "debug: posy=" . $player->{y} . "\n";
	} elsif (/d/) {
		if ($climb_mode) {
			if (can_climb) {
				my $nx = $player->{x} + 1/8;
				my $y = $player->{y};

				if (can_move($nx, $y, $player)) {
					$player->{x} = $nx;
					change_screen;
					$sprmoved++;
				}
			}
		} else {
			$vx = $player->{vx};

			$vx += $player->{walkspeed};

			if ($vx > $player->{walkspeed} or $inair) {
				$vx = $player->{walkspeed};
			}

			$player->{vx} = $vx;
		}

		print "debug: posx=" . $player->{x} . "\n";
		print "debug: posy=" . $player->{y} . "\n";
	} elsif (/w/) {
		if (can_climb) {
			my $x = $player->{x};
			my $ny = $player->{y} + 1/8;

			if (can_move($x, $ny, $player)) {
				$player->{y} = $ny;
				change_screen;
				$sprmoved++;
			}
		}
	} elsif (/s/) {
		my ($x, $y, $i);
		$x = int $player->{x};
		$y = int($player->{y} - 1 + $small_value);

		for (@portals) {
			$i++;
			if (($x == $_->[0]) and ($y == $_->[1])) {
				make_animation($x, $y, $i, "down");
			}
		}
		if (can_climb) {
			my $x = $player->{x};
			my $ny = $player->{y} - 1/8;

			if (can_move($x, $ny, $player)) {
				$player->{y} = $ny;
				change_screen;
				$sprmoved++;
			}
		}
	} elsif (/A/) {
		$player->{x}-=1/16;
		$walk--;
		$sprmoved++;
		change_screen;
	} elsif (/D/) {
		$player->{x}+=1/16;
		$walk++;
		$sprmoved++;
		change_screen;
	} elsif (/W/) {
		$player->{y}+=1;  #=1/16;
		$sprmoved++;
		change_screen;
	} elsif (/S/) {
		$player->{y}-=1/16;
		$sprmoved++;
		change_screen;
	} elsif (/R/) {
		$race ^= 1;
	} elsif (/r/) {
		draw_world;
		print "curses:ref\n";
	} elsif (/e/) {
		$floor_shift++;
		draw_world;
	} elsif (/E/) {
		$floor_shift--;
		draw_world;
	} elsif (/f/) {
		set_floor_shift;
	} elsif (/f/) {
		$auto_floor_shift ^= 1;
	} elsif (/-/) {
		$scrn--;
		if ($scrn<0){ $scrn=0 };
		draw_world 
	} elsif (/\+/) {
		$scrn++;
		draw_world 
	} elsif (/q/) {
		#print "curses:quit\n";
		hide_all;
		exit 0;
	} elsif (/Q/) {
		save_all;
		hide_all;
		exit 1;
	} elsif (/i/) {
	} elsif (/l/) {
		print "curses:stats\n";
	} elsif (/t/) {
		my ($x, $y);
		$x = int ($player->{x} + 1 + .5);
		$y = int $player->{y} - 1;

		$world[$x][$y] = $constr_char;
		$show_constr_bar = 1;

		draw_world;

		#print "curses:grpdel:screen$nscr\n";
		#$vx=0;
	} elsif (/T/) {
		$read_constr = 1;

		#print "curses:rmparts\n";
		#set_alarm();
	} elsif (/3/) {
		print "curses:spr:backdrop:" . 2 * $tile_width * $scrw . ":" 				. 2 * $tile_height * $scrh . "\n";
		$backdrop=1;
		draw_world;
		print "curses:ref\n";
	} elsif (/4/) {
		print "curses:hide:backdrop\n";
		print "curses:ref\n";
	} elsif (/5/) {
		print "curses:show:backdrop\n";
		print "curses:ref\n";
	} elsif (/6/) {
		$debuginfo^=1;
	} elsif (/7/) {
		print "search\n";
	my ($x, $y) = find_spawn_point();
		print "/search $x; $y\n";
		#$x=5; $y=3;
		#change_screen;
		draw_world;
		print_pl_coord;
	} elsif (/x/) {
		$player->{swim} ^= 1;
	} elsif (/X/) {
		init_srv
		size_init
	} elsif (/g/) {
		go_to_save_point;
	} elsif (/8/) {
		print "debug:", @portals, "\n";
	} elsif (/9/) {
		$show_coords ^= 1;
		draw_world;
	} elsif (/p/) {
		print "curses:pr:\033]4;1;#53186f\007\n";
	} elsif (/y/) {
		Time::HiRes::ualarm(0);
	} elsif (/ /) {
		if ($player->{swim}) {
			$player->{vy} = .2;
		} else {
			if (!$inair) {
				$player->{vy} = .8;
				$inair++;
				$climb_mode = 0;
			} else {
				$player->{y} -= 1;
			}
		}
	} elsif (/b/) {
		$sshift--;
		print "curses:grpdel:screen$nscr\n";
		print "curses:ref\n";
	} elsif (/n/) {
		$sshift++;
		print "curses:shft:backdrop:$sshift\n";
		print "curses:ref\n";
	} elsif (/k/) {
		$kx=$okx;
	}
}

sub proc_cmd
{
	$_=$_[0];
	my $mutex_all;
	lock $mutex_all;
	
	if (/^user:key=(.*)/) {
		if ($read_constr) {
			$constr_char = $1;
			$read_constr = 0;
		} else {
			process_key($1);
		}
	} elsif (/^user:screen:loaded/) {
		#set_alarm();
	} elsif (/^user:init/) {
		#print "curses:pr:tst\n";
		sleep 1;
		init_srv
	} elsif (/^user:resize:([^:]*):([^:]*)/) {
		$scrw=$1 / $tile_width;
		$scrh=$2 / $tile_height;
		#$scrh=2 * $2 / $tile_height;

		$scrw=int $scrw;
		$scrh=int $scrh;
		
		undef @loaded_screens;

		print "curses:spr:backdrop:" . 2 * $tile_width * $scrw . ":"
			. 2 * $tile_height * $scrh . "\n";

		if (!$inited) {
			size_init;
		} else {
			# FIXME: Should I delete the old one?
			
			# update;	# only when player can't spawn
			#change_screen or do { draw_world; }; #$sprmoved=1; repaint; };
			change_screen;
			draw_world;	# Repaint screen either way, because $nscr may 
					# not always be different.
		}
		print "curses:ref\n";
	}
	#unlock $mutex_all;
}

print "mod:use:out&&in&&net&&file&&curses\n"; 

while (<STDIN>) { lock $mutex_all; proc_cmd $_ };
