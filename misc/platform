#!/usr/bin/perl
#!/usr/bin/env perl
use Time::HiRes;
use Safe;

$scr_x = 0;
$scr_y = 0;

$scrw = 5;
$scrh = 3;

$spr_w = 1;  # Dimensions of a generic sprite. To be replaced with "sprite->{h}"
$spr_h = 1;  # of each particular sprite, not same for all sprs like now.
$py_spr_w = $spr_w;	# Dimensions of player sprite
$py_spr_h = 2*$spr_h;
 
$tile_width = 16;
$tile_height = 16;

$tile_width = 8;
$tile_height = 8;

$tile_width = $tile_height = $ENV{TILE_SIZE};

$tile_rows = int($tile_height / 2);
$pixel_width = 1/$tile_width;
$pixel_height = 1/$tile_height;
$fall_dec = 1 / 16;
$small_value = 0.005;

$state_file = $ENV{STATE};

$|++;
$nscr = 0;
$num_objects = 0;

$origsprs = 88;

#$updps = 20;
$fps = 20;
$pdelay = 1000000/$fps;

$repaint = 0;
$sprmoved = 0;
$walk = 0;
$, = ", ";
$vx = 0;
$vy = 0;
$inair = 1;

# $worldh = 13;
# $n12 = 12;

# $data_dir = "data";
chdir $ARGV[0];
sub draw_world;

$object_created = 0;

$compartment = new Safe;
$compartment->permit(qw(time sort :browse print require));

$exit_status = "Teleported";
$status = "Running";

sub reval($)
{
        my $cmd = shift;
        return $compartment->reval($cmd);
}

sub set_floor_shift
{
	sub draw_world;

	$floor_shift = $n12 - $scrh - 1 - (($player->{y} % $scrh) || $scrh);
	$floor_shift = $scrh - $floor_shift - 3;
	draw_world;
}

sub change_screen2 {
	while ($player->{x} > $scr_x + $scrw) {
		$scr_x += $scrw;
	}
	while ($player->{x} < $scr_x) {
		$scr_x -= $scrw;
	}
	while ($player->{y} > $scr_y + $scrh) {
		$scr_y += $scrh;
	}
	while ($player->{y} < $scr_y) {
		$scr_y -= $scrh;
	}
}

sub print_pl_coord
{
	if (!$debuginfo) {
		return;
	}
	print "curses:pr:";
	print "posx=" . $player->{x};
	print ", posy=" . $player->{y};
	print ", nscrx=$nscr=" . nscr($player->{x});
	print ", nscry=$nscry=" . nscry($player->{y});
	print ", flr_shft=$floor_shift";
	print ", nscrsy=$worldh/$scrh -1=$nscrsy";
	print ", rnscry=$rnscry";
	print ", start_y=$start_y";
	print ", scr_x=$scr_x";
	print ", oth_scr=" . $other_scr->{x} . "," . $other_scr->{y};
	print ", scr_size=" . $scrw . "," . $scrh;
	print "          \n";
	print "curses:ref\n";
}

sub print_dbg
{
	my $first=0;
	print "curses:pr:";

	for my $v (@_)
	{
		if ($first++) { print ", " }
		print "$v=" . eval("\$$v");
	}

	print "          \ncurses:ref\n";
}

sub load_object
{
	$module = shift;
	$module =~ s/[^A-Za-z:]//g;
	eval("use $module");
}

sub is_on_screen {
	my ($x, $y, $w, $h) = @_;

	if (($x + $w > $scr_x) and ($x < $scr_x + $scrw) and
	    ($y + $h > $scr_y) and ($y < $scr_y + $scrh)) {
		return 1;
	} else {
		return 0;
	}
}

sub obj_on_screen
{
	my $object = shift;
	my $x = $object->{x};
	my $y = $object->{y};
	my $w = $object->{w};
	my $h = $object->{h};

	return is_on_screen($x, $y, $w, $h);

	#$x += $main::nscr;
	#$y += $main::nscry;
	#if ( main::onscr ($x, $w) == $main::nscr and
	#     main::is_on_scr_y($y, $h, $main::nscry) ) {

	     #main::onscry($y, $h) == $main::nscry) {
	#	return 1;
	#} else {
	#	return 0;
	#}
}

sub destroy_object	# NOT USED
{
        my $obj = shift;
        @objects = grep {$_ != $obj} @objects;
}

sub destroy_object_id
{
        my $id = shift;
	undef $objects[$id];
}

sub id_to_object
{
        my $id = shift;

	for $obj (@objects) {
		if ($obj->{id} == $id) {
        		return $obj;
		}
	}
} 

sub get_objects_num
{
	return $num_objects;
}

sub load_modules
{
	push $mod_dir, @INC;

	@mods = < $mod_dir/*.pm >;

	$ln = q( for my $mod (@mods) {require $mod} );
	jail->reval($ln);
}

sub process_status {
	for ($status) {
		if (/Teleported to (.*)/) {
			$player->{x} = $portals[$1-1][0] + .5;
			$player->{y} = $portals[$1-1][1] + 1 + $small_value;
			make_animation($player->{x}, $player->{y} - 1, $1, "up");
		}
	}
}

sub save_all
{
	use Data::Dumper;

	$result = Data::Dumper->Dump([\@objects], ["\*objects"]);
	$result .= Data::Dumper->Dump([\%state], ["\*state"]);
	$result .= Data::Dumper->Dump([$player->{id}], ["\*player_id"]);
	$result .= Data::Dumper->Dump([$status], ["\*status"]);
	$result .= Data::Dumper->Dump([$worldh], ["\*worldh"]);
	$result .= Data::Dumper->Dump([$world_h], ["\*world_h"]);

        open STATE, ">$state_file";
        print STATE $result;
        close STATE;
}

sub load_all
{
        open STATE, "<$state_file";
        my $code = join " ", <STATE>;
	$code =~ s/\n//g;
        close STATE;
	eval($code);
	$player = id_to_object($player_id);
	process_status;
}

sub low_draw
{
	my $self = shift;
	my ($x, $y);
	my $sprite = $self->{sprite};

	if (obj_on_screen($self)) {
		if (!$self->{visible}) { $self->show }
	} else {
		if ($self->{visible}) { $self->hide }
		return;
	}

	$x  = $self->left;
	my $h = $self->{h};
	my $ry = $self->{y};
	#$y  = $worldh * 0  - $self->top;
	$y = $self->top;

	# my $feet_on_top = (onscry($ry, $h) == $nscry);
	# my $feet_on_top = ( int(($ry - 1) / $scrh) == $nscry);
	my $feet_on_top;
	if (is_on_screen($x, $ry - 1, $self->{w}, $h)) {
		 $feet_on_top = 1;
	}
	my $x_shift = $nscr * (int $scrw);
#	my $y_shift = $scrh * $nscry; 

	my $x_shift = $scr_x;

	$x-=$x_shift;
#	$y-=$y_shift;

#	$y += $n12;# - $scrh;	# This line positions spr rel to top-of-screen.
				# Without it, it will be pos-d rel-ve to
				# the scr-bottom.
	# $y += 1;


	# for - y's while drawing on screen (feet only)

#	if ($feet_on_top) {
#		$y += $self->{h};
#	}

	# $y -= $small_value;	# Always show a sprite on its 'feet' screen.

	$y -= $scr_y;
	#$y = $scrh - $y + 2 * $h;
	$y = $scrh - $y;
	$y += $floor_shift;

	$x *= $main::tile_width;
	$y *= $main::tile_height;

#	$x  = $x % ($scrw * $main::tile_width);
#	$y  = $y % ($scrh * $main::tile_height);

#	if ($feet_on_top) {
#		$y -= $self->{h} * $main::tile_height;
#	}

	$y += 1;
	$x = int $x;
	$y = int $y;

	print "curses:mvs2:$sprite:$x:$y\n";
}

#reval q(

package Player {
sub new()
{
	my ($class, $x, $y) = @_;
	my $self={};
	bless($self, $class);

	$self->{x}=$x;
	$self->{y}=$y;
	$self->{w}=1;
	$self->{h}=2;
	$self->{id} = main::get_objects_num();	#scalar @main::objects;
	$self->{type}=$class;
	$self->{alive}=1;
	$self->{visible}=1;
	$self->{walkspeed}=@{$main::object{character}{walkspeed}}[0];
	my $i=1;
	for $s (@{$main::object{"character"}{"walk"}})
	{
		print "curses:newspr:character.walk.$i:" . $s . "\n";
		print "curses:newspr:character.walk.$i.+1:" . $s . ".+1\n";
		$i++;
		print "mk loop\n";
	}
	return $self;
}

sub draw
{
	my $self = shift;

	my $walk = $main::walk/2 % 3 + 1;
	$self->{sprite} = "character.walk.$walk"; 
	$self->hideall();
	print "curses:show:$sprite\n";
	main::low_draw($self);
}

sub hi()
{
	my $self = shift;
	print "clas s debug hi\n";
}

sub update {
	# Must exist because alive == true, so this m-d is called,
	#  like for all other objects. 
}

sub hideall
{
	my $self = shift;
	print "curses:hide:character.walk.1\n";
	print "curses:hide:character.walk.2\n";
	print "curses:hide:character.walk.3\n";
	print "curses:hide:character.walk.1.+1\n";
	print "curses:hide:character.walk.2.+1\n";
	print "curses:hide:character.walk.3.+1\n";
}

sub hide
{
	my $self = shift;
	my $i=1;
	$self->{visible}=0;
	for $s (@{$main::object{"character"}{"walk"}})
	{
		print "curses:hide:character.walk.$i:" . $s . "\n";
		print "curses:hide:character.walk.$i.+1:" . $s . ".+1\n";
		$i++;
	print "hide loop\n";
	}
}

sub kill()
{
	my $self = shift;
	$self->{y}=$worldh;
	$self->{x}=3;
	# You don't actually kill the player object.
	# undef $main::objects[ $self->{id} ];
}

sub top
{
	my $self = shift;
	return $self->{y} + $self->{h};
}

sub left
{
	my $self = shift;
	return $self->{x};
}

sub bottom
{

}

1;
}


package BrokenBrick {
sub new
{
	my ($class, $x, $y) = @_;
	my $self={};
	bless($self, $class);
	#my $id = scalar @main::objects;
	my $id = main::get_objects_num();
	$self->{x}=$x;
	$self->{y}=$y;
	$self->{id}=$id;
	$self->{vx}=.3;
	$self->{vy}=.3;
	$self->{alive}=1;
	$self->{w}=1;
	$self->{h}=1;
	$self->{type}=$class;
	$self->{id}=$id;
	$id = $id % 4 + 1;	# Sprite names are 1 through 4.
	$self->{sprite}="broken_brick_$id";
	$self->{vx} *= ($id & 1) ? 1 : -1;
	$self->{vy} *= ($id & 2) ? 1 : -1;
	$self->{x} += 2 * $self->{vx};
	$self->{y} += 2 * $self->{vy};

	return $self;	
}

sub hide
{
	my $self = shift;
	my $sprite = $self->{sprite};

	$self->{visible}=0;
	print "curses:hide:$sprite\n";
}

sub show
{
	my $self = shift;
	my $sprite = $self->{sprite};

	$self->{visible}=1;
	print "curses:show:$sprite\n";
}

sub draw
{
	my $self = shift;

	main::low_draw($self);
	$main::repaint++;
}

sub update
{
	my $self = shift;
	$self->{vy} -= $main::fall_dec;
	$self->{y} += $self->{vy};
	$self->{x} += $self->{vx};
	$self->draw();
	if ($self->{y} < 0) {
		$self->kill();
	}
}

sub kill
{
	my $self = shift;
	$self->hide();
	$self->{alive}=0;
	# undef $main::objects[ $self->{id} ];
	main::destroy_object($self);
}
	
sub top
{
	my $self = shift;
	return $self->{y} + $self->{h};
}

sub left
{
	my $self = shift;
	return $self->{x};
}


1;
}

package Klop {
sub new
{
	my ($class, $x, $y)=@_;
	
	my $self={};
	bless($self, $class);

	$self->{x}=$x;
	$self->{y}=$y;
	$self->{ox}=$x;
	$self->{oy}=$y;
	$self->{w}=1;
	$self->{h}=1;
	$self->{alive}=1;
	$self->{visible}=0;
	$self->{id} = main::get_objects_num();
	#$self->{id} = scalar @main::objects;
	$self->{type}=$class;
	$self->{move}+=@{$main::object{"klop"}{"move"}}[0];

	my $i=0;
	for $s (@{$main::object{"klop"}{"walk"}})
	{
		print "curses:newspr:klop" . $self->{id} . ".walk.$i:" . $s 
			. "\n";
		$i++;
		print "mkklop\n";
	}
	$self->hide();

	return $self;
}

sub show
{
	print "show klop\n";
	my $k=$_[0];
	$k->{visible}=1;
	print "curses:show:klop$k->{id}.walk.0\n";
	print "curses:show:klop$k->{id}.walk.1\n";
}

sub hide
{
	print "hide klop\n";
	my $self = shift;
	$self->{visible}=0;
	print "curses:hide:klop" . $self->{id} . ".walk.0\n";
	print "curses:hide:klop" . $self->{id} . ".walk.1\n";
	print "curses:hide:klop" . $self->{id} . ".walk.0.+1\n";
	print "curses:hide:klop" . $self->{id} . ".walk.1.+1\n";
	print "curses:ref\n";
}

sub kill
{
	print "kill klop\n";
	my $self = shift;
	$self->hide();
	$self->{alive}=0;
	# undef $main::objects[ $self->{id} ];
	main::destroy_object($self);
}

sub draw
{
	print "draw klop\n";
	my $self = shift;

	if ($self->{visible}) {
	my $num_walk=@{$main::object{"klop"}{"walk"}};
	my $walk=( $main::tile_width * $self->{x} ) % $num_walk;

	for (my $nwalk=0; $nwalk<@{$main::object{"klop"}{"walk"}}; $nwalk++) {
		if ($nwalk==$walk) {
			print "curses:show:klop" . $self->{id} . ".walk.$nwalk\n";
		} else {
			print "curses:hide:klop" . $self->{id} . ".walk.$nwalk\n";
			print "curses:hide:klop" . $self->{id} . ".walk.$nwalk.+1\n";
		}
print "paint klop\n";
	}
	$self->{sprite} = "klop" . $self->{id} . ".walk.$walk";
	}
	main::low_draw($self);

	$main::repaint++;
}

sub top
{
	my $self = shift;
	return $self->{y} + $self->{h};
}

sub left
{
	my $self = shift;
	return $self->{x};
}

sub update
{
	print "update klop\n";
	my $self = shift;
	my $x=$self->{x};
	my $y=$self->{y};
	my $h=$self->{h};
	my $w=$self->{w};

	if ($x<-$w) { $self->kill(); return }
	if ($y>$main::worldh) { $self->kill(); return }

	my $nx=$x+$self->{move};
	my $ny=$y-$main::fall_dec;


	#if (main::can_move($nx, $y+$main::pixel_height-$h, $main::spr_w, $h-$main::pixel_height, True)) {
	#if (main::can_move($nx, $y+$main::pixel_height, $main::spr_w, $h-$main::pixel_height, True)) {


	if (main::can_move($nx, $y+$main::small_value, $self)) {
		$self->{x}=$nx;
	} else {
		$self->{move} *= -1;
		print "klop cant move: $x, $y while mario is at $a, $b\n";
	}


	#if (main::can_move($x, $ny+$main::pixel_height-$h, $main::spr_w, $h-$main::pixel_height, True)) {
	#if (main::can_move($x, $ny+$main::pixel_height, $main::spr_w, $h-$main::pixel_height, True)) {


	if (main::can_move($x, $ny, $self)) {
		$self->{y}=$ny;
	}

	print "Drawing klop: $x, $y\n";
	$self->draw();	
}
1;
}

package Portal_Down {
sub new
{
	my ($class, $x, $y) = @_;
	my $self={};
	bless($self, $class);
	#my $id = scalar @main::objects;
	my $id = main::get_objects_num();
	$self->{x}=$x;
	$self->{y}=$y;
	$self->{id}=$id;
	return $self;
}

1;
}

package AnimationDive {
sub new
{
	my ($class, $x, $y) = @_;
	my $self={};
	bless($self, $class);
	#my $id = scalar @main::objects;
	my $id = main::get_objects_num();
	$self->{x}=$x;
	$self->{y}=$y;
	$self->{h}=2;
	# $self->{oy}=$y;
	# $self->{dest_y}=$y - 2;
	$self->{id}=$id;
	$self->{alive}=1;
	$self->{type}=$class;
	$self->{visible}=1;
	# $main::world[i][]

	return $self;
}

sub update {
	my $self = shift;
	my $dec = .05;
	my $recip = 1 / $dec;

	print "debug:anim:upd\n";

	my $fract = $self->{x} - int $self->{x};
	my $diff = .5 + $dec - $fract;

	my $sign = $diff > 0 ? -1 : 1;

	if (abs($diff) > $dec) {
		$self->{x} -= $dec * $sign;
	}

	my $new_y = $self->{y} + $dec * $self->{direct};
	my $diff_y = $new_y - $self->{dest_y};

	if (abs($diff_y) > $dec ) { 
		$self->{y} = $new_y;
		print "y=", $self->{y}, "\n";
		$self->draw();
	} else {
		$self->{on_done}($self);
	}
}

sub draw {
	my $self = shift;
	print "debug:anim:draw y=$self->{y}\n";

	my $walk = $main::walk/2 % 3 + 1;
	$self->{sprite} = "character.walk.$walk"; 
	# $self->hideall();
	# print "curses:show:$self->{sprite}\n";
	# my ($x, $y) = (int $self->{x}, int $self->{y}); 
	# print "curses:mvs2:$sprite:$x:$y\n";
	main::low_draw($self);

	my $spr = $self->{sprite};
	my ($rx, $ry) = ($self->{x}, $self->{y});
	$self->{sprite} = "over";
	($self->{x}, $self->{y}) = ($self->{over_x}, $self->{over_y});
	
	main::low_draw($self);
	$self->{sprite} = $spr;
	($self->{x}, $self->{y}) = ($rx, $ry);
	#print "curses:ref\n";
	$main::repaint = 1;
}

sub top
{
	my $self = shift;
	return $self->{y} + $self->{h};
}

sub left
{
	my $self = shift;
	return $self->{x};
}

sub hide {

}

1;
}

#);

sub nscr
{
	my $x = $_[0];
	return int ($x/$scrw);
	#return int ($x/($scrw+1));
}

sub onscr
{
	my $x = $_[0];
	my $w = $_[1];
	#return int ($x/$scrw);
	return int (($x+$w)/($scrw+1));
}

sub onscr2
{
	my $x = $_[0];
	return int ($x/$scrw);
}
sub nscry
{
	my $y = $_[0];
	return int (($y-1)/($scrh));
	#return int (($y-1-$pixel_height)/($scrh)); # This fixes char spawn.
	#return int (($y-1+$pixel_height)/($scrh));
	#return int (($y-2*$pixel_height)/($scrh));
	#return int (($y-1)/($scrh));
	#return int (($y)/($scrh));
	#return int ($y/($scrh));
}

sub onscry
{
	my $y = $_[0];
	my $h = $_[1];
	return int (($y-1)/($scrh));
	#return int ($y/($scrh + $h));
}

sub onscry2
{
	my $y = $_[0];
	return int (($y)/($scrh));
}

sub is_on_scr_y
{
	my ($y, $h, $scr_y) = @_;

	my $scr_top = $scr_y * $scrh;
	my $scr_bottom = $scr_top + $scrh;

	my $spr_top = $y - $h;
	my $spr_bottom = $y;

	if ( $spr_top <= $scr_bottom and
	     $spr_bottom >= $scr_top ) {
		return 1;
	} else {
		return 0;
	}
}

sub set_alarm()
{
	$SIG{ALRM}=\&update; Time::HiRes::ualarm($pdelay);
}

sub unset_alarm()
{
	undef $SIG{ALRM};
	Time::HiRes::ualarm(0);
}

# not used, remove
sub load_screen
{
	my ($scr) = @_;

	unset_alarm();
	draw_world($scr->{x}, $scr->{y}, True);
	if ($object_created) {
		set_alarm();
	}
}

sub change_screen
{

	$old_scr_x = $scr_x;
	$old_scr_y = $scr_y;

	change_screen2;

	# $onscr = $nscr;
	# $onscry = $nscry;

	$nscr=nscr($player->{x});
	$nscry=nscry($player->{y});

	# if ($nscr!=$onscr or $nscry != $onscry){

	if ($scr_x != $old_scr_x or $scr_y != $old_scr_y){
		unset_alarm();
		draw_world;
		if ($object_created) {
			set_alarm();
		}
		return 1
	}

	return 0
}

sub gettypes
{
	$k = $_[0];
	@k2 = split(/\s+/, $types3{$k});	
	return @k2;
}

#TODO: ADD THESE IN CODE!!!
#curses:hide:sprf
#curses:progsprinc:load


sub cat_file
{
	my $file=$_[0];

	print "debug_:$file\n";
	my @lines=`cat $file`;
	for my $line (@lines) { print $line }

	# or just system("cat $file");
	return @lines;
}

sub load_config
{
	open CONF, "<$_[0]";
	my @conf=<CONF>;
	close CONF;
	return @conf;
}

sub load_logo {
	my $logo_file = $ENV{LOGO} || "logo.crs";
	my @logo=cat_file($logo_file);		

	$logo[0] =~ /spr:logo:([^:]+):([^:]+)/;
	my $lx = int (($tile_width * $scrw-$1)/2);
	my $ly = int (($tile_height * $scrh-2*$2)/2);
	print "curses:mvs2:logo:$lx:$ly\n";
	print "curses:ref\n";
}

sub def_types {
	my (%legend) = @_;
	print "legend=", %legend, "\n";
	print "legend keys=", keys %legend, "\n";
	for my $type (keys %legend) {
		for my $field (@{$legend{$type}}) {

			print "type=$type; field=$field\n";
			if ($field eq "obst") {
				push @obst, $type;
			} elsif ($field eq "brick") {
				push @brick, $type;
			} elsif ($field =~ /^show=(.*)/) {
				$t_show{$type} = $1;
				if ($t_show{$type} eq "") {
					$t_show{$type} = " ";
				}
				print "type=$type; field=$field match $t_show{$type}=$1\n";
			} elsif ($field eq "klop") {
				push @t_klop, $type;
			} elsif ($field eq "box") {
				push @box, $type;
			} elsif ($field eq "portal_down") {
				push @portal, $type;
			} elsif ($field eq "player") {
				push @t_player, $type;
			} else {
				print "type=$type; field=$field error $t_show{$type}\n";
				push @t_error, $type;
				$t_show{$type} = " ";	# To draw attention.
			}
		}
		if (not $type ~~ [@obst, @brick, @box, @portal, keys %t_show]) {
			push @t_walk, $type;
		}
	}
}

sub load_legend {
	my $legend_file = $ENV{LEGEND} || "level.legend";
	my @types2 = load_config "$legend_file";
	for (@types2)
	{
		if (/^\s*\/\//) { next }
		if (/^(.)\s*=\s*(.*)/) {
			$types3{$1} = $2;
		}
	}
	for my $k (keys %types3) {
		@types4{$k} = [gettypes($k)]; #FIXME WHY???
	}

	def_types(%types4);
}

sub load_objects_config {
	my $objects_file = $ENV{OBJECTS} || "objects.txt";
	my @obj = load_config "$objects_file";
	for (@obj)
	{
		if (/^\s*\/\//) { next }
		if (/^\s*(\S+)\.(\S+)\s*=\s*(.*)/) {
			@{$object{$1}{$2}} = split(/\s+/, $3);
		}
	}
}

sub mkworld
{
	load_logo;
	cat_file("sprites.crs");		
	load_legend;
	load_objects_config;
}

sub check_sqr_pt
{
	my ($sx, $sy, $sex, $sey, $px, $py)=(@_);
	if ( ($px>$sx && $px<$sex) && ($py>$sy && $py<$sey) ) {
		return 1;
	}

	return 0;
}

sub check_squares
{
	my ($sx, $sy, $ex, $ey, $sx2, $sy2, $ex2, $ey2)=(@_);
	if ( check_sqr_pt($sx, $sy, $ex, $ey, $sx2, $sy2) ||
	     check_sqr_pt($sx, $sy, $ex, $ey, $sx2, $ey2) ||
	     check_sqr_pt($sx, $sy, $ex, $ey, $ex2, $sy2) ||
	     check_sqr_pt($sx, $sy, $ex, $ey, $ex2, $ey2) ) {
		return 1;
	}
	else { return 0 }
}

sub can_move
{
	my ($objx, $objy, $obj) = @_;
	my $objw=$obj->{w};
	my $objh=$obj->{h};
	#my ($objx, $objy, $objw, $objh, $obj_is_klop) = @_;
#	$objy-=1;
#	return 1;
	my $leftsqr=int($objx);

	# This weird math is legit for bumping into things from the left.
	my $rightsqr=int($objx + $objw - $small_value + 1);

	my $topsqr=int($objy);
	my $botsqr=int($objy + $objh);
	#my $botsqr=int($objy + $objh - $pixel_height);
#	($botsqr, $topsqr) = (13-$topsqr, 13-$botsqr);
	($botsqr, $topsqr) = ($topsqr, $botsqr);
#	($botsqr, $topsqr) = ($topsqr, $botsqr);
#	$topsqr -= $worldh;
#	$botsqr -= $worldh;

	for (my $i=$leftsqr; $i<$rightsqr; $i++) {
		for (my $j=$botsqr; $j<=$topsqr; $j++) {
			#my $sqr=$world[$i][$j];
			my $sqr = get_sprite($i, $j);

			if ($sqr ~~ @t_walk) {
				next;
			} elsif ($sqr ~~ @obst) {
				return 0;
			} elsif ($sqr ~~ @brick) {

				#my $plr_to_btm=$objy - $j -1;
				#print "brick:j=$j; y=$objy dist=$plr_to_btm\n";
				#if ($vy > 0 && $plr_to_btm < .5) {
				#FIXME: This assumes p->{w} == brick->w == 1
				#print "brick: i=$i; x=$objx dist=$plr_to_btm\n";
				if ($vy > 0 and $obj->{type} eq "Player") {
					$world[$i][$j]="\"";
					my $x = $i + .5;
					my $y = $j  + .5;
					#my $y = 12 - $j  + .5;

					for (my $i=0; $i<4; $i++) {
						create_object($x, $y, 
							"BrokenBrick");
					}

					draw_world;
					return 0;
				} else {
					return 0;
				}
				
			} elsif ($sqr ~~ @box) {
				if ($vy > 0 && !$obj_is_klop) {
					create_object($i, $j + 1, "Klop");
					$world[$i][$j]="Z";
					draw_world;
				}
				return 0;
			} elsif ($sqr ~~ @one_way_wall) {
				# This type may be used in the future. 
				if ($vy<0) {
					return 0;
				}
			}
			print "can move 1\n";
		}
	}

	if ($obj->{type} eq "Player") {
		my $oex=$objx + $objw;
		my $oey=$objy + 2*$objh;
		my $ox=$objx;
		my $oy=$objy;

		for my $k (@objects) {
			print "k=$k\n";
			if ($k->{type} ne "Klop") { next }
			if (!$k->{alive}) { next }

			print "can move 2 $a, $b\n";
			my $kx=$k->{x};
			my $ky=$k->{y};
			my $kex=$kx + $k->{w};
			my $key=$ky + $k->{h};

			if ( check_squares($ox, $oy, $oex, $oey,
			              $kx, $ky, $kex, $key) ) {
				if ($inair && $vy<0) {
					$k->kill;
					$vy/=-2;
				} else {
					$player->kill();
				}
			}
		}
	} elsif (False) { 		#FIXME: old coords
		my $oex=$objx+$objw;
		my $oey=$objy+2*$objh;
		my $ox=$objx;
		my $oy=$objy;

			#$k=mario
			#if (!$k->{alive}) { next }

			my $kx=$a;
			my $ky=$b;
			my $kex=$kx+$psprw;
			my $key=$ky+$psprh;

			if ( check_squares($ox, $oy, $oex, $oey,
			              $kx, $ky, $kex, $key) ) {
				if ($inair && $vy<0) {
					killklop $k;
					$vy/=-2;
				} else {
					$player->kill;
				}
			}
		
	}

	return 1;
}

# not used
sub provide_screen
{
	my ($scr_a) = @_;
	my $scr = $scr_a->{x} . "," . $scr_a->{y};
	
	# The game slows down when load_screen is called indiscriminately.
	# This might mean there are leaks / unkilled objs updating.

	if (not $scr ~~ @loaded_screens) {
		load_screen($scr_a);
		push @loaded_screens, $scr;
	}
}

# not used, remove
sub check_other_screens
{
	my ($x, $y, $w, $h) = @_;

	my %r_scr;

	$r_scr->{x} = $nscr;
	$r_scr->{y} = $nscry;

	my $ret_x;
	my $ret_y;

	my $scr_x_seft = onscr2($x);
	my $scr_x_right = onscr2($x + $w);
	my $scr_y_top = onscry2($y + $h);
	my $scr_y_bottom = onscry2($y);

	if ($scr_x_right > $nscr) {
		$r_scr->{x} = $scr_x_right;
		$ret_x = 1;
	} elsif ($scr_x_seft < $nscr) {
		$r_scr->{x} = $scr_x_seft;
                $ret_x = 1;
	}

        if ($scr_y_bottom < $nscry) {
                $r_scr->{y} = $scr_y_bottom;
                $ret_y = 1;
        } elsif ($scr_y_top > $nscry) {
                $r_scr->{y} = $scr_y_top;
                $ret_y = 1;
        }

	if ($ret_x or $ret_y) {
		return $r_scr;
	}
}

sub fast_fall
{
	my ($na, $nb) = @_;

	# For falling down and bumping stones.
	#$vy = ($vy<0) ? -$pixel_height : $pixel_height; 
	$vy = -$fall_dec;
	
	while (True) {
		$nb=$player->{y}+$vy;
		print "fast fall loop $a, $b\n";


		#if (can_move($player->{x}-$spr_w-$nscr, $nb-$py_spr_h, $spr_w, $spr_h-$pixel_height)) {
		#if (can_move($player->{x}, $nb, $spr_w, $spr_h-$pixel_height)) {


		if (can_move($player->{x}, $nb, $player)) {
			$player->{y}=$nb;
			change_screen;
			$sprmoved++;
		}
		else {
			$vy=0;
			$inair=0;
			last;
		}
	}
	if ($auto_floor_shift) {
		set_floor_shift;
	}
}

sub updmove
{
	$vy-=$fall_dec; 

	print "debug:anim:updmove, alive= $player->{alive}\n";

	my $x = $player->{x};
	my $y = $player->{y};
	my $w = $spr_w;
	my $h = $spr_h - $fall_dec;

	$sprmoved++;

	$rundec=@{$object{character}{walkstop}}[0];

	if (!$inair) {
		if ($vx > $rundec) { 
			$vx -= $rundec
		} elsif (abs($vx) > $rundec) {
			$vx += $rundec
		} else {
			$vx = 0
		}
	}

	my $nx = $x + $vx;
	my $ny = $y + $vy;

#	$other_scr = check_other_screens($nx, $ny, $w, $h);

#	if ($other_scr) {
#		provide_screen($other_scr);
#	}

	if ($vy) {


		#if (can_move($x, $ny, $w, $h)) {


		if (can_move($x, $ny, $player)) {
			$player->{y} = $ny;
			change_screen;
			$sprmoved++;
			$inair = 1;
		}
		else {
			#this var breaks the game
			$vy = 0;
			$inair &&
				fast_fall($nx, $ny);
		}
	}	

	if (1 or $vx) {
		#if (can_move($nx, $y, $w, $h)) {

		if (can_move($nx, $y, $player)) {
			$player->{x} = $nx;
			$walk += ($vx > 0) ? 1 : -1;
			#change_screen2;
			change_screen;
			$sprmoved++;
		}	
	}	
	if ($player->{x} < 0) { $player->{x} = 0 }
	#if ($player->{y} > $worldh) { $player->kill }
	if ($player->{y} < 0) { $player->kill }
	# elsif ($player->{y} > $worldh) { $player->hide }
	else {
		if (!$player->{visible}) { $player->{visible} = 1 }
	}
}

sub update_all_objects
{
	#reval q(
	for my $o (@objects) {
		if ($o->{alive}) { 
			$o->update();
		}
	}
	#);
}

sub update
{
	print "upd\n";

	if (!$in_updmove) {		# and $object_created) {
		$in_updmove=1;
		update_all_objects();
		if ($player->{type} ne "AnimationDive") { # if for anim.
			updmove;
		}
		$in_updmove=0;
	}
	if ($sprmoved) {
		$sprmoved=0;
		#$player->hi;
		if ($object_created){
			#reval q(
			$player->{visible} && $player->draw();
			#);
		}
		$repaint=1;
	}
	if ($repaint) {
		print "curses:ref\n";
		# Prevent jerkiness.
		flush STDOUT;
		$repaint=0;
	}
	print_pl_coord;
	set_alarm();
}

sub load_world
{
	my ($x, $y);
	my $map_file=$ENV{MAP_FILE} || "level.map";
	open(F, "<$map_file");
	while (<F>) {
		chomp;
		for ($y=0; 1; $y++) {
			my $val = substr $_, $y, 1;

			if ($y > $world_h) {
				$world_h = $y;
			}

			if ($y == length $_) {
				$y--; # We shouldn't've run this time, so no ++.
				last;
			} else {
				$world[$x][$y] = $val;
			}
		}
		$x++;
	}
	$world_w=$x; 
	#$world_h=$y; 
	$worldh=$world_h;
	close F;
}

sub draw_square
{
	my ($x, $y, $spr_type) = @_;

	for (@{$types4{$spr_type}}) {
		if ($_ eq "hide") { next }
	}

	if (defined $t_show{$spr_type}) {
		$spr_type = $t_show{$spr_type};
	}

	# my $scr_shift_x=int($scrw+$inter_scr_w) * $nscr ;
	# my $scr_shift_y=int($scrh+$inter_scr_h) * $nscry;

	my $sx=$x-$scr_x;
	my $sy=$y-$scr_y;		# These odd arithmetics are needed
	# $sy-=int($scrh) * $nscrsy;	# to compensate for what happened to y
					# in the function get_what_on_screen().
					# The $sy -= ...$nscrsy line is for the
					# added $nscry,
					# The plus sign in +$scr_shift_y is for
					# $nscry that was taken with a minus
					# sign in that function.

	print "ultradebug: sx=$sx, sy=$sy, sy2=$sy2, type=$sprtype\n";

	print "debug: i=$x, j=$y, sy=$sy\n"; 
	$sy=$scrh-$sy-1;

	$sx *= $tile_width;
	$sy *= $tile_rows;
	
	#$y=$worldh-$y;
#	$y=$n12-$y;

	# Print coords at their pos, not at sprite origin.
	$dsy = $sy + $tile_height/2 - 1;

	print "curses:paste:backdrop:spr$spr_type:0:0:$sx:$sy:$tile_width:$tile_rows\n";
	if ($show_coords) {
		$y += $floor_shift;
		print "curses:prc:backdrop:$sx:$dsy:7:0:$x,$y\n";
	}
}

sub create_object
{
	my ($x, $y, $type) = @_;
	my $o = $type->new($x, $y);
	$num_objects++;
	push @objects, $o;

	return $o;
}

sub create_object_once
{
	my ($x, $y, $type) = @_;
	my $obj;

	if (defined $state{"$x,$y"}) {
		my $id = $state{"$x,$y"};
		$obj = $objects[$id]; 
	} else {
		$obj = create_object($x, $y, $type);
		$state{"$x,$y"} = $obj->{id};
	}

	return $obj;
}

sub load_square
{
	my ($x, $y, $type) = @_;

#	$y = $n12 - $y;	# 13 would spawn obj's 1 $y above.
	print "debug: loading sqr $x $y\n";
	#for (@{$types4{$type}}) {
		if ($type ~~ @t_klop) {
			create_object_once($x, $y, "Klop");
			#print "loading klop at $x,$y\n";
		} 
		elsif ($type ~~ @t_player) {
			print "debug: player created\n";
			$player = create_object_once($x, $y, "Player");
			# start updating only when player has spawned
			update;
			$object_created=1;
		}
		print "type loop\n";
	#}
}

sub get_sprite
{
	my ($x, $y) = @_;

	# Upside down because $y is reversed for drawing.
#	$y=$n12-$y;

#	if (($y<0) || ($y>=$worldh)) {
#		return $world[0][0];
#	}
#	my $spr_type=$world[$x][$y] ne "" ?
#		$world[$x][$y] : 
#		$world[0][0];

	my $spr_type = $world[$x][$y] //
		$world[0][0];

	return $spr_type;
}

sub botch {
	@a = <0 15 8 5 3 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1 1>;
	return ${a[int $scrh]};
}

sub get_what_on_screen
{
	my ($nscr, $nscry) = @_;
	#my $start_x = int($scrw) * $nscr; 
	my $start_x = $scr_x; 
	my $end_x = $start_x + $scrw;
	#$nscrsy = int ($worldh / int($scrh)) - 1;
	#$nscrsy += ($worldh % int($scrh)) ? 1 : 0;
	 $nscrsy = botch() - 1;

	#if ($nscrsy < 1) {
	#	$nscrsy=0;
	#}
 
	#$nscrsy = 0; # $worldh / int($scrh);
	#$nscrs += $scrh%1 ? 1 : 0;
	#my $rnscry = $nscrsy - $nscry;
	$rnscry = $nscrsy - $nscry;
	# my $start_y = int($scrh) * ($worldhurr+$rnscry); 
	$start_y = int($scrh) * ($worldhurr+$rnscry); 
	my $end_y = $start_y + $scrh;

	$start_y = $scr_y; 
	my $end_y = $start_y + $scrh;

	print "s:$start_y e:$end_y\n";
	return $start_x, $start_y, $end_x, $end_y;
}

sub draw_world
{
	my ($lscr_x, $lscr_y, $don_t_draw) = @_;
	$lscr_x //= $nscr;
	$lscr_y //= $nscry;

	print "loading screen x=$nscr; y=$nscry\n";

	my ($start_x, $start_y, $end_x, $end_y)
		= get_what_on_screen($lscr_x, $lscr_y);

	for (my $x=$start_x; $x < $end_x; $x++) {
		for (my $y=$start_y; $y < $end_y; $y++) {
			my $spr_type = get_sprite($x, $y);
			
			load_square($x, $y, $spr_type);

			$spr_type = get_sprite($x, int($y - $floor_shift));
			if (not defined $don_t_draw) {
				draw_square($x, $y, $spr_type);
			}
			print "sqr loop\n";
			print "sqr: j=$y\n";
		}
	}
}


sub init_srv
{
	my $sprw = $spr_w * $tile_width;
	my $sprh = $spr_h * $tile_height;

	print "curses:init:1\n";
	print "curses:clear\n";
#	print "curses:lnmode:1\n";
#	print "curses:progspr:load:$origsprs\n";
	print "curses:spr:walk1:$sprw:$sprh\n";
	print "curses:spr:walk2:$sprw:$sprh\n";
	print "curses:spr:walk3:$sprw:$sprh\n";
	print "curses:spr:walk1.+1:$sprw:$sprh\n";
	print "curses:spr:walk2.+1:$sprw:$sprh\n";
	print "curses:spr:walk3.+1:$sprw:$sprh\n";
#	print `bash -c 'cd \`dirname $0\`; cat data/*.crs'`;
}

sub find_spawn_point
{
	my $pl_char="|";
	my ($x, $y);
	for ($x=0; $x<=$world_w; $x++) {
		for ($y=0; $y<=$worldh; $y++) {
			print "x=$x,y=$y, " . $world[$x][$y] . "\n";
			if ($world[$x][$y] eq $pl_char) {
				return $x, $y;
			}
		}
	}
	
	print "no fnd\n";
	print "x=$x,y=$y, " . $world[$x][$y] . "\n";
	die("No spawn point on map\n");
}

sub find_type {
	my ($x, $y, @res);
	my @class = @{$_[0]};
	for ($x=0; $x<=$world_w; $x++) {
		for ($y=0; $y<=$worldh; $y++) {
			print "x=$x,y=$y, " . $world[$x][$y] . "\n";
			if ($world[$x][$y] ~~ @class) {
				push @res, [$x, $y];
			}
		}
	}
	return @res;
}

sub make_animation {
	my ($x, $y, $i, $direct) = @_;
	$x = int $x;
	$y = int $y;
	my $id = $player->{id};
	my $anim = create_object($player->{x}, $y + 1, "AnimationDive");
	my ($spr0, $spr1, $spr2, $spr3);
	# $objects[$id] = $anim;
	$anim->{object} = $player;
	$anim->{direct} = $direct eq "up" ? 1 : -1;
	$anim->{depart} = $i; #	Or use eval.
	$player->{alive} = 0;
	if ($direct eq "down") {
		$anim->{dest_y} = $y - 2 + 1;
		$anim->{on_done} = sub {
			my ($anim2) = @_;
	
			$status = "Teleporting from $anim2->{depart}";
			$player = $anim2->{object};
			main::destroy_object($anim2);
			save_all;
			print "curses:hide:over\n";
			exit 1;
		};
	} else {
		$anim->{dest_y} = $y + 1;
		$anim->{y} = $y - 2 + 1;
		$anim->{on_done} = sub {
			my ($anim2) = @_;

			$player = $anim2->{object};
			print "curses:hide:over\n";
			main::destroy_object($anim2);
		};
	}
	$spr0 = $world[$x][$y];
	$spr1 = $world[$x][$y - 1];
	$spr2 = $world[$x + 1][$y];
	$spr3 = $world[$x + 1][$y - 1];

	print "curses:spr:over:" . $tile_width * 2 . ":" . $tile_rows * 2 . "\n";
	print "curses:paste:over:spr$spr0:0:0:0:0:$tile_width:$tile_rows\n";
	print "curses:paste:over:spr$spr1:0:0:0:4:$tile_width:$tile_rows\n";
	print "curses:paste:over:spr$spr2:0:0:8:0:$tile_width:$tile_rows\n";
	print "curses:paste:over:spr$spr3:0:0:8:4:$tile_width:$tile_rows\n";
	$anim->{over_x} = $x; 
	$anim->{over_y} = $y - 1;
	$player = $anim;
}

sub init_jail
{
	$compartment->share("\$player");
	$compartment->share("\@objects");
	$compartment->share("get_objects_num");
	$compartment->share("low_draw");
	$compartment->share("destroy_object");
	$compartment->share("\$tile_width");
	$compartment->share("\$tile_height");
	$compartment->share("\$repaint");
	$compartment->share("\$pixel_height");
	$compartment->share("\$fall_dec");
	$compartment->share("\$small_value");
	$compartment->share("\$spr_w");
	$compartment->share("\$nscr");
	$compartment->share("\$nscry");
	$compartment->share("onscr");
	$compartment->share("is_on_scr_y");
	$compartment->share("\%object"); # check types !!
	$compartment->share("\$walk");
	$compartment->share("\$worldh");
	$compartment->share("can_move");
}

sub spawn_player
{
	print "search\n";
	my ($x, $y) = find_spawn_point();
	$player->{x} = $x;
	$player->{y} = $y;
	change_screen;
	print "/search $x; $y\n";
	# $nscr=nscr($x);
	# $nscry=nscry($y);
	print "1/scr $nscr; $nscry\n";
}

sub size_init
{
	$inited=1;
	mkworld;
	load_world;

	push @INC, "./modules/";
	my @m = `ls | sed -n "s/\\.pm\$//p"`;
	for my $m (@m) {
		chomp $m;
		load_object($m);
	}

	@portals = find_type( [ "@", "n", "u" ] );

	load_all;

	if (defined $player_id or $dont_spawn) {
		$object_created = 1;
	} else {
		spawn_player;
	}

	#change_screen;
	print "2/scr $nscr; $nscry\n";
	print "scr_dims $scrw; $scrh\n";
	draw_world;
	print_pl_coord;
	#update;
	#FIXME: complex backticks don't work in chroot

	init_jail;

	print "curses:hide:logo\n";
}

sub process_key
{
	$_=$_[0];
	if (/a/) {
		$vx=-$player->{walkspeed};
		print "debug: posx=" . $player->{x} . "\n";
		print "debug: posy=" . $player->{y} . "\n";
	} elsif (/d/) {
		$vx=$player->{walkspeed};
		print "debug: posx=" . $player->{x} . "\n";
		print "debug: posy=" . $player->{y} . "\n";
	} elsif (/w/) {
	} elsif (/s/) {
		my ($x, $y, $i);
		$x = int $player->{x};
		$y = int($player->{y} - 1 + $small_value);

		for (@portals) {
			$i++;
			if (($x == $_->[0]) and ($y == $_->[1])) {
				make_animation($x, $y, $i, "down");
			}
		}
	} elsif (/A/) {
		$player->{x}-=1/16;
		$walk--;
		$sprmoved++;
		change_screen;
	} elsif (/D/) {
		$player->{x}+=1/16;
		$walk++;
		$sprmoved++;
		change_screen;
	} elsif (/W/) {
		$player->{y}+=1;  #=1/16;
		$sprmoved++;
		change_screen;
	} elsif (/S/) {
		$player->{y}-=1/16;
		$sprmoved++;
		change_screen;
	} elsif (/R/) {
		#$player->{x}=1/16;
		$player->{y}=1/16;
		$sprmoved++;
	} elsif (/r/) {
		draw_world;
		print "curses:ref\n";
	} elsif (/e/) {
		$floor_shift++;
		draw_world;
	} elsif (/E/) {
		$floor_shift--;
		draw_world;
	} elsif (/f/) {
		set_floor_shift;
	} elsif (/f/) {
		$auto_floor_shift ^= 1;
	} elsif (/-/) {
		$scrn--;
		if ($scrn<0){ $scrn=0 };
		draw_world 
	} elsif (/\+/) {
		$scrn++;
		draw_world 
	} elsif (/q/) {
		#print "curses:quit\n";
		exit 0;
	} elsif (/Q/) {
		save_all;
		exit 1;
	} elsif (/i/) {
		print "debug:a=$a, b=$b, $nscr, $nscry\n";
	} elsif (/l/) {
		print "curses:stats\n";
	} elsif (/t/) {
		#print "curses:grpdel:screen$nscr\n";
		$vx=0;
	#	print_dbg("nscry","player->{x}");
	} elsif (/T/) {
		#print "curses:rmparts\n";
		set_alarm();
	} elsif (/3/) {
		print "curses:spr:backdrop:" . 2 * $tile_width * $scrw . ":" 				. 2 * $tile_height * $scrh . "\n";
		$backdrop=1;
		draw_world;
		print "curses:ref\n";
	} elsif (/4/) {
		print "curses:hide:backdrop\n";
		print "curses:ref\n";
	} elsif (/5/) {
		print "curses:show:backdrop\n";
		print "curses:ref\n";
	} elsif (/6/) {
		$debuginfo^=1;
	} elsif (/7/) {
		print "search\n";
	my ($x, $y) = find_spawn_point();
		print "/search $x; $y\n";
		#$x=5; $y=3;
		$nscr=nscr($x);
		$nscry=nscry($y)+1;
		#change_screen;
		draw_world;
		print_pl_coord;
	} elsif (/8/) {
		print "debug:", @portals, "\n";
	} elsif (/9/) {
		$show_coords ^= 1;
		draw_world;
	} elsif (/p/) {
		print "curses:pr:\033]4;1;#53186f\007\n";
	} elsif (/y/) {
		Time::HiRes::ualarm(0);
	} elsif (/ /) {
		if (!$inair) {
			$vy=.8;
			$inair++;
		}
	} elsif (/b/) {
		$sshift--;
		print "curses:grpdel:screen$nscr\n";
		print "curses:ref\n";
	} elsif (/n/) {
		$sshift++;
		print "curses:shft:backdrop:$sshift\n";
		print "curses:ref\n";
	} elsif (/k/) {
		$kx=$okx;
	}
}

sub proc_cmd
{
	$_=$_[0];
	
	if (/^user:key=(.*)/) {
		process_key($1);
	} elsif (/^user:screen:loaded/) {
		#set_alarm();
	} elsif (/^user:init/) {
		#print "curses:pr:tst\n";
		sleep 1;
		init_srv
	} elsif (/^user:resize:([^:]*):([^:]*)/) {
		$scrw=$1 / $tile_width;
		$scrh=$2 / $tile_height;
		#$scrh=2 * $2 / $tile_height;

		$scrw=int $scrw;
		$scrh=int $scrh;
		
		undef @loaded_screens;

		print "curses:spr:backdrop:" . 2 * $tile_width * $scrw . ":"
			. 2 * $tile_height * $scrh . "\n";

		if (!$inited) {
			size_init;
		} else {
		
		# FIXME: Should I delete the old one?
		
		# update;	# only when player can't spawn
		#change_screen or do { draw_world; }; #$sprmoved=1; repaint; };
		change_screen;
		draw_world;	# Repaint screen either way, because $nscr may 
				# not always be different.
		}
		print "curses:ref\n";
	}
}

print "mod:use:out&&in&&net&&file&&curses\n"; 

while (<STDIN>) { proc_cmd $_ };
