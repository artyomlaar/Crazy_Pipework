#!/bin/perl
#!/usr/bin/env perl
use Time::HiRes;

$scrw=5;
$scrh=3;

$spr_w=1;  # Dimensions of a generic sprite. To be replaced with "sprite->{h}"
$spr_h=1;  # of each particular sprite, not same for all sprs like now.
$py_spr_w=$spr_w;	# Dimensions of player sprite
$py_spr_h=2*$spr_h;

$tile_width=16;
$tile_height=16;
$tile_rows=8;
$pixel_width=1/$tile_width;
$pixel_height=1/$tile_height;

$|++;
$nscr=0;

$origsprs=88;

#$updps=20;
$fps=20;
$pdelay=1000000/$fps;

$repaint=0;
$sprmoved=0;
$walk=0;
$,=", ";
$vx=0;
$vy=0;
$inair=1;
$nklop=0;

$worldh=13;

$data_dir="data";

sub draw_world;


sub nscr
{
	my $x = $_[0];
	return int ($x/($scrw+1));
}

sub onscr
{
	my $x = $_[0];
	my $w = $_[1];
	return int (($x+$w)/($scrw+1));
}

sub nscry
{
	my $y = $_[0];
	return int (($y-2*$pixel_height)/($scrh));
	#return int ($y/($scrh));
}

sub onscry
{
	my $y = $_[0];
	my $h = $_[1];
	#return int (($y)/($scrh));
	return int ($y/($scrh + $h));
}

sub set_alarm()
{
	$SIG{ALRM}=\&update; Time::HiRes::ualarm($pdelay);
}

sub unset_alarm()
{
	undef $SIG{ALRM};
	Time::HiRes::ualarm(0);
}

sub change_screen
{
	$onscr=$nscr;
	$onscry=$nscry;
	$nscr=nscr($a);
	$nscry=nscry($b);


	if ($nscr!=$onscr){
		unset_alarm();
		draw_world;
		set_alarm();
		return 1
	}
	if ($nscry!=$onscry){
		unset_alarm();
		draw_world;
		set_alarm();
		return 1
	}

	return 0
}

sub mkklop
{
	my %k;
	my $kx=$_[0];
	my $ky=$_[1];
	if ($state[$kx][$ky]) { return }
	$k{x}=$kx;
	$k{y}=$ky;
	$k{ox}=$_[0];
	$k{oy}=$_[1];
	$k{w}=1;
	$k{h}=1;
	$k{alive}=1;
	$k{visible}=1;
	$k{id}=scalar @klop;
	$k{move}+=@{$object{"klop"}{"move"}}[0];
	$state[$kx][$ky]=1;

	my $i=0;
	for $s (@{$object{"klop"}{"walk"}})
	{
		print "curses:newspr:klop$k{id}.walk.$i:" . $s . "\n";
		$i++;
print "mkklop\n";
	}

	return \%k;
}

sub showklop
{
	my $k=$_[0];
	$k->{visible}=1;
	print "curses:show:klop$k->{id}.walk.0\n";
	print "curses:show:klop$k->{id}.walk.1\n";
}

sub hideklop
{
	my $k=$_[0];
	$k->{visible}=0;
	print "curses:hide:klop$k->{id}.walk.0\n";
	print "curses:hide:klop$k->{id}.walk.1\n";
	print "curses:hide:klop$k->{id}.walk.0.+1\n";
	print "curses:hide:klop$k->{id}.walk.1.+1\n";
	print "curses:ref\n";
}

sub killklop
{
	my $k=$_[0];
	hideklop $k;
	$k->{alive}=0;
}

sub repaintklop
{
	my ($x, $y, $walk, $k) = @_;
	for (my $nwalk=0; $nwalk<@{$object{"klop"}{"walk"}}; $nwalk++) {
		if ($nwalk==$walk) {
			print "curses:show:klop$k->{id}.walk.$nwalk\n";
		} else {
			print "curses:hide:klop$k->{id}.walk.$nwalk\n";
			print "curses:hide:klop$k->{id}.walk.$nwalk.+1\n";
		}
print "paint klop\n";
	}
	$x-=$k->{w};
	$x*=$tile_width;
	$y*=$tile_height;
	print "curses:mvs2:klop$k->{id}.walk.$walk:$x:$y\n";
}

sub drawklop
{
	my $k=$_[0];
	my $hx=$k->{x}+$nscr;
	my $hy=$k->{y}+$nscry;

	if (onscr($hx, $k->{w})!=$nscr) {
		if ($k->{visible}) { hideklop $k }
		return;
	} else {
		if (!$k->{visible}) { showklop $k }
	}

	if (onscry($hy, $k->{h})!=$nscry) {
		if ($k->{visible}) { hideklop $k }
		return;
	} else {
		if (!$k->{visible}) { showklop $k }
	}

	my $nwalk=@{$object{"klop"}{"walk"}};
	my $walkn=( $tile_width * $k->{x} ) % $nwalk;

	repaintklop( (int(($hx + $k->{w}) * $tile_width) % ($tile_width * ($scrw + $k->{w})) ) / $tile_width, 
	             (int($hy * $tile_height) % ($tile_height * ($scrh + $k->{h}))) / $tile_height,
	             #int($k->{y})%($scrh+$k->{h}*2),
	             $walkn,
		     $k );

	$repaint++;
}

sub mkcharacter
{
	$a=$_[0];
	$b=$_[1];
	$charactervisible=1;
	$walkspeed=@{$object{character}{walkspeed}}[0];
	my $i=1;
	for $s (@{$object{"character"}{"walk"}})
	{
		print "curses:newspr:character.walk.$i:" . $s . "\n";
		print "curses:newspr:character.walk.$i.+1:" . $s . ".+1\n";
		$i++;
print "mk loop\n";
	}

}
sub hidecharacter
{
	my $i=1;
	$charactervisible=0;
	for $s (@{$object{"character"}{"walk"}})
	{
		print "curses:hide:character.walk.$i:" . $s . "\n";
		print "curses:hide:character.walk.$i.+1:" . $s . ".+1\n";
		$i++;
print "hide loop\n";
	}
}

sub killcharacter    #   ;_; 
{
	$b=0;
}

sub gettypes
{
	$k=$_[0];
	@k2=split(/\s+/, $types3{$k});	
	return @k2;
}

sub cat_file
{
	my $file=$_[0];

	print "debug_:$file\n";
	my @lines=`cat $file`;
	for my $line (@lines) { print $line }

	# or just system("cat $file");
	return @lines;
}

sub openconf
{
	open CONF, $_[0];
	my @conf=<CONF>;
	close CONF;
	return @conf;
}

sub mkworld
{
	@script2=openconf("<$data_dir/script.txt");
	print "debug1:", @script2, "\n";
	for (@script2)
	{
		if (/^\s*\/\//) { next }
		if (/^\s*(\S+)\.(\S+)\s*=\s*(.*)/) {
			@{$script{$1}{$2}}=split(/\s+/, $3);
		}
	}

	my @logo=cat_file("$data_dir/@{$script{main}{title_screen}}[0]");		
	print "debug0:$data_dir/@{$script{main}{title_screen}}[0]\n";

	$logo[0] =~ /spr:logo:([^:]+):([^:]+)/;
	my $lx=int (($tile_width * $scrw-$1)/2);
	my $ly=int (($tile_height * $scrh-$2)/2);
	print "curses:mvs2:logo:$lx:$ly\n";
	print "curses:ref\n";

	print "debug2:", @{$script{level_1}{files_to_load}}, "\n";
	for (@{$script{level_1}{files_to_load}}) {
		cat_file("$data_dir/$_");		
		print "debug3:", $_, "\n";
	}

	@types2=openconf "<$data_dir/@{$script{level_1}{char_types}}[0]";
	for (@types2)
	{
		if (/^\s*\/\//) { next }
		if (/^(.)\s*=\s*(.*)/) {
			$types3{$1}=$2;
		}
	}
	for $k (keys %types3) {
		@types4{$k}=[gettypes($k)]; #FIXME WHY???
	}
	@obj=openconf "<$data_dir/@{$script{level_1}{object_info}}[0]";
	for (@obj)
	{
		if (/^\s*\/\//) { next }
		if (/^\s*(\S+)\.(\S+)\s*=\s*(.*)/) {
			@{$object{$1}{$2}}=split(/\s+/, $3);
		}
	}

	@conf1=openconf "<$data_dir/@{$script{main}{config}}[0]";
	for (@conf1)
	{
		if (/^\s*\/\//) { next }
		if (/^\s*(\S+)\.(\S+)\s*=\s*(.*)/) {
			@{$conf{$1}{$2}}=split(/\s+/, $3);
		}
	}
}

sub checksquares
{
	my $objx=$_[0];
	my $objy=$_[1];
	my $objw=$_[2];
	my $objh=$_[3];

}

sub chckptsqr
{
	my ($sx, $sy, $sex, $sey, $px, $py)=(@_);
	if ( ($px>$sx && $px<$sex) && ($py>$sy && $py<$sey) ) {
		return 1;
	}

	return 0;
}

sub sqrs_ist
{
	my ($sx, $sy, $ex, $ey, $sx2, $sy2, $ex2, $ey2)=(@_);
	if ( chckptsqr($sx, $sy, $ex, $ey, $sx2, $sy2) ||
	     chckptsqr($sx, $sy, $ex, $ey, $sx2, $ey2) ||
	     chckptsqr($sx, $sy, $ex, $ey, $ex2, $sy2) ||
	     chckptsqr($sx, $sy, $ex, $ey, $ex2, $ey2) ) {
		return 1;
	}
	else { return 0 }
}

sub can_move
{
	my ($objx, $objy, $objw, $objh, $obj_is_klop) = @_;
	my $leftsqr=int($objx);
	my $rightsqr=int($objx + $objw - $pixel_width + 1);
	my $topsqr=int($objy);
	my $botsqr=int($objy + $objh - $pixel_height + 1);
	($botsqr, $topsqr) = (12-$topsqr, 12-$botsqr);
	($botsqr, $topsqr) = ($topsqr, $botsqr);

	for (my $i=$leftsqr; $i<$rightsqr; $i++) {
		for (my $j=$botsqr; $j<=$topsqr; $j++) {
			my $sqr=$world[$i][$j];
			if ($sqr eq ""){ next }
			if ($sqr ~~ @obst){ return 0 }
print "can move 1\n";
		}
	}

	if (!$obj_is_klop) {
		my $oex=$objx + $objw;
		my $oey=$objy + 2*$objh;
		my $ox=$objx;
		my $oy=$objy;

		for my $k (@klop) {
			if (!$k->{alive}) { next }

print "can move 2 $a, $b\n";
			my $kx=$k->{x};
			my $ky=$k->{y};
			my $kex=$kx + $k->{w};
			my $key=$ky + $k->{h};

			if ( sqrs_ist($ox, $oy, $oex, $oey,
			              $kx, $ky, $kex, $key) ) {
				if ($inair && $vy<0) {
					killklop $k;
					$vy/=-2;
				} else {
					killcharacter;
				}
			}
		}
	} elsif (False) { 		#FIXME: old coords
		my $oex=$objx+$objw;
		my $oey=$objy+2*$objh;
		my $ox=$objx;
		my $oy=$objy;

			#$k=mario
			#if (!$k->{alive}) { next }

			my $kx=$a;
			my $ky=$b;
			my $kex=$kx+$psprw;
			my $key=$ky+$psprh;

			if ( sqrs_ist($ox, $oy, $oex, $oey,
			              $kx, $ky, $kex, $key) ) {
				if ($inair && $vy<0) {
					killklop $k;
					$vy/=-2;
				} else {
					killcharacter;
				}
			}
		
	}

	return 1;
}

sub repaint;

sub fast_fall
{
	my ($na, $nb) = @_;

	$vy=-$pixel_height; 

	while (True) {
		$nb= $b-$vy;
		print "fast fall loop $a, $b\n";

		if (can_move($a-$spr_w-$nscr, $nb-$py_spr_h, $spr_w, $spr_h-$pixel_height)) {
			$b=$nb;
			change_screen;
			$sprmoved++;
		}
		else {
			$vy=0;
			$inair=0;
			last;
		}
	}
}

sub updmove
{
	my $na, $nb;

	$vy-=$pixel_height; 
	$rundec=@{$object{character}{walkstop}}[0];
	if (!$inair) {
		if ( $vx>$rundec ) { $vx-=$rundec }
		elsif ( abs($vx)>$rundec ) { $vx+=$rundec }
		else { $vx=0 }
	}

	$na= $a+$vx;
	$nb= $b-$vy;

	if ($vy) {
		if (can_move($a-$spr_w-$nscr, $nb-$py_spr_h, $spr_w, $spr_h-$pixel_height)) {
			$b=$nb;
			change_screen;
			$sprmoved++;
			$inair=1;
		}
		else {
			$vy=0;
			$inair &&
				fast_fall($na,$nb);
		}
	}	

	if ($vx) {
		if (can_move($na-$spr_w-$nscr, $b-$py_spr_h, $spr_w, $spr_h-$pixel_height)) {
			$a=$na;
			$walk+=$vx>0?1:-1;
			change_screen;
			$sprmoved++;
		}	
	}	
	if ($a<$spr_w) { $a=$spr_w }
	if ($b>$worldh) { killcharacter }
	elsif ($b<0) { hidecharacter }
	else {
		if (!$charactervisible) { $charactervisible=1 }
	}
}

sub updklop
{
	my $k=$_[0];
	my $kx=$k->{x};
	my $ky=$k->{y};
	my $kh=$k->{h};
	my $kw=$k->{w};
	my $kw=$k->{w};

	if ($kx<-$kw) { killklop $k; return }
	if ($ky>$worldh) { killklop $k; return }

	my $nkx=$kx+$k->{move};
	my $nky=$ky+$pixel_height;

	if (can_move($nkx, $ky+$pixel_height-$kh, $spr_w, $kh-$pixel_height, True)) {
		$k->{x}=$nkx;
	} else {
		$k->{move} *= -1;
		print "klop cant move: $kx, $ky while mario is at $a, $b\n";
	}

	if (can_move($kx, $nky+$pixel_height-$kh, $spr_w, $kh-$pixel_height, True)) {
		$k->{y}=$nky;
	}

	print "Drawing klop: $kx, $ky\n";
	drawklop $k;	
}

sub update
{
	for my $k (@klop) {
		if ($k->{alive}) { updklop $k }
		print "klop loop\n";
	}

	if (!$in_updmove) {
		$in_updmove=1;
		updmove;
		$in_updmove=0;
	}
	if ($sprmoved) {
		$sprmoved=0;
		$charactervisible && repaint;
		$repaint=1;
	}
	if ($repaint) {
		print "curses:ref\n";
		$repaint=0;
	}
	set_alarm();
}

sub load_world
{
	$map_file=$ENV{MAP_FILE} // "$data_dir/w1-1.txt";
	open(F, "<$map_file");
	while (<F>) {
		for (my $j=0; $j<15; $j++) {
			$world[$i][$j]=substr $_, $j, 1;
		}
		$i++;
	}
	close F;
}
sub draw_square
{
	my ($i, $j) = @_;
	my $sprtype=$world[$i][12-$j] ne "" ?
		$world[$i][12-$j] : 
		$world[0][0];
	my $rx=$i;
	my $sx=$i-$scrw*$nscr;
	my $sy=$j-$scrh*$nscry;
	#$sy=int($sy/2);
	#$sy=int($sy/2);
	$k=$sprtype;
	for (@{$types4{$k}}) {
		if ($_ eq "obst") { push @obst, $k }
		if ($_ eq "klop") { push @klop, mkklop($rx, $sy+$scrh*$nscry)}
		if ($_ eq "hide") { next }
		if ($_ eq "player") { mkcharacter($rx+1, $sy+$scrh*$nscry) }
	#	if (/show=(.+)/) { $sprtype=$1 } #FIXME 
		if (/show=(.*)/) { $sprtype=$1 || " " }
		print "type loop\n";
	}

	print "curses:paste:backdrop:spr$sprtype:0:0:" . $sx * $tile_width
		. ":" . $sy * $tile_rows . ":16:8\n";
}

sub draw_world
{
	for (my $i=int($scrw)*$nscr; $i<$scrw*($nscr+1); $i++) {
		for (my $j=int($scrh)*$nscry; $j<$scrh*($nscry+1); $j++) {
			draw_square($i, $j);
			print "sqr loop\n";
		}
	}
}

sub init_srv
{
	my $sprw = $spr_w * $tile_width;
	my $sprh = $spr_h * $tile_height;

	print "curses:lnmode:1\n";
	print "curses:progspr:load:$origsprs\n";
	print "curses:spr:walk1:$sprw:$sprh\n";
	print "curses:spr:walk2:$sprw:$sprh\n";
	print "curses:spr:walk3:$sprw:$sprh\n";
	print "curses:spr:walk1.+1:$sprw:$sprh\n";
	print "curses:spr:walk2.+1:$sprw:$sprh\n";
	print "curses:spr:walk3.+1:$sprw:$sprh\n";
#	print `bash -c 'cd \`dirname $0\`; cat data/*.crs'`;
}

sub sizeinit
{
	$inited=1;
	
	mkworld;

	
	#FIXME: complex backticks don't work in chroot

	#mkcharacter(150,158);

	load_world;

	print "curses:hide:logo\n";
}

sub hideall
{
	print "curses:hide:character.walk.1\n";
	print "curses:hide:character.walk.2\n";
	print "curses:hide:character.walk.3\n";
	print "curses:hide:character.walk.1.+1\n";
	print "curses:hide:character.walk.2.+1\n";
	print "curses:hide:character.walk.3.+1\n";
}

sub hideall2
{
	print "curses:hide:walk1\n";
	print "curses:hide:walk2\n";
	print "curses:hide:walk3\n";
	print "curses:hide:walk1.+1\n";
	print "curses:hide:walk2.+1\n";
	print "curses:hide:walk3.+1\n";
}

sub draws
{
	hideall
	print "curses:show:character.walk." . ($walk/2%3+1) . "\n";
	print "curses:mvs2:character.walk." . ($walk/2%3+1) . ":"
		. int($_[0] * $tile_width) . ":" . int($_[1] * $tile_height) . "\n";
}

sub repaint
{
	#draws ($a%($scrw+$sprw)-$sprw, $b%($scrh+$sprh*2)-$sprh*2)
	#draws ($a%($scrw+$sprw)-$sprw, $b%($scrh)-$sprh*2)
	#draws ($a % ($scrw + $spr_w) - $spr_w,
	#    ($b - 2 * $pixel_height) % ($scrh) - $spr_h * 2 + 2 * $pixel_height)
	draws ($a - $nscr * ($scrw + $spr_w) - $spr_w,
	    $b - 2 * $pixel_height - $scrh * $nscry - $spr_h * 2 + 2 * $pixel_height)
}

sub proc_cmd
{
	$_=$_[0];

	if (/^user:key=a/) {
		$vx=-$walkspeed;
	} elsif (/^user:key=d/) {
		$vx=$walkspeed;
	} elsif (/^user:key=w/) {
	} elsif (/^user:key=s/) {
	} elsif (/^user:key=A/) {
		$a-=1/16;
		$walk--;
		$sprmoved++;
	} elsif (/^user:key=D/) {
		$a+=1/16;
		$walk++;
		$sprmoved++;
	} elsif (/^user:key=W/) {
		$b--;
		$sprmoved++;
	} elsif (/^user:key=S/) {
		$b++;
		$sprmoved++;
	} elsif (/^user:key=r/) {
		draw_world;
		print "curses:ref\n";
	} elsif (/^user:key=-/) {
		$scrn--;
		if ($scrn<0){ $scrn=0 };
		draw_world 
	} elsif (/^user:key=\+/) {
		$scrn++;
		draw_world 
	} elsif (/^user:key=q/) {
		#print "curses:quit\n";
		exit
	} elsif (/^user:key=i/) {
		print "debug:a=$a, b=$b, $nscr, $nscry\n";
	} elsif (/^user:key=l/) {
		print "curses:stats\n";
	} elsif (/^user:key=t/) {
		print "curses:grpdel:screen$nscr\n";
	} elsif (/^user:key=T/) {
		print "curses:rmparts\n";
	} elsif (/^user:key=3/) {
		print "curses:spr:backdrop:" . 2 * $tile_width * $scrw . ":" 				. 2 * $tile_height * $scrh . "\n";
		$backdrop=1;
		draw_world;
		print "curses:ref\n";
	} elsif (/^user:key=4/) {
		print "curses:hide:backdrop\n";
		print "curses:ref\n";
	} elsif (/^user:key=5/) {
		print "curses:show:backdrop\n";
		print "curses:ref\n";
	} elsif (/^user:key=p/) {
		print "curses:pr:\033]4;1;#53186f\007\n";
	} elsif (/^user:key=y/) {
		Time::HiRes::ualarm(0);
	} elsif (/^user:key= /) {
		if (!$inair) {
			$vy=.8;
			$inair++;
		}
	} elsif (/^user:key=b/) {
		$sshift--;
		print "curses:grpdel:screen$nscr\n";
		print "curses:ref\n";
	} elsif (/^user:key=n/) {
		$sshift++;
		print "curses:shft:backdrop:$sshift\n";
		print "curses:ref\n";
	} elsif (/^user:key=k/) {
		$kx=$okx;
	} elsif (/^user:screen:loaded/) {
		set_alarm();
	} elsif (/^user:init/) {
		#print "curses:pr:tst\n";
		sleep 1;
		init_srv
	} elsif (/^user:resize:([^:]*):([^:]*)/) {
		$scrw=$1 / $tile_width;
		$scrh=$2 / $tile_height;
		if (!$inited) { sizeinit }
		# FIXME: Should I delete the old one?
		print "curses:spr:backdrop:" . 2 * $tile_width * $scrw . ":" 				. 2 * $tile_height * $scrh . "\n";
		
		update;
		change_screen or do { draw_world; }; #$sprmoved=1; repaint; };
		print "curses:ref\n";
	}
}

print "mod:use:out&&in&&net&&file&&curses\n"; 

while (<>) { proc_cmd $_ };
